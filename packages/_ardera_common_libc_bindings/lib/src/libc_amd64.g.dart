// ignore_for_file: constant_identifier_names, non_constant_identifier_names, camel_case_types, unnecessary_brace_in_string_interps, unused_element, no_leading_underscores_for_local_identifiers, unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'ssize_t.dart' as pkg_ssizet;

/// libc backend for amd64
class LibCAmd64 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibCAmd64(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibCAmd64.fromLookup(ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup) : _lookup = lookup;

  ffi.Pointer<ffi.Int> errno_location() {
    return _errno_location();
  }

  late final _errno_locationPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function()>>('__errno_location');
  late final _errno_location = _errno_locationPtr.asFunction<ffi.Pointer<ffi.Int> Function()>(isLeaf: true);

  int open(
    ffi.Pointer<ffi.Char> __file,
    int __oflag,
  ) {
    return _open(
      __file,
      __oflag,
    );
  }

  late final _openPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>('open');
  late final _open = _openPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>(isLeaf: true);

  int close(
    int __fd,
  ) {
    return _close(
      __fd,
    );
  }

  late final _closePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('close');
  late final _close = _closePtr.asFunction<int Function(int)>(isLeaf: true);

  int read(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _read(
      __fd,
      __buf,
      __nbytes,
    );
  }

  late final _readPtr =
      _lookup<ffi.NativeFunction<pkg_ssizet.SSize Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int)>>('read');
  late final _read = _readPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  int write(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
  ) {
    return _write(
      __fd,
      __buf,
      __n,
    );
  }

  late final _writePtr =
      _lookup<ffi.NativeFunction<pkg_ssizet.SSize Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int)>>('write');
  late final _write = _writePtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  int ioctl(
    int __fd,
    int __request,
  ) {
    return _ioctl(
      __fd,
      __request,
    );
  }

  late final _ioctlPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.UnsignedLong)>>('ioctl');
  late final _ioctl = _ioctlPtr.asFunction<int Function(int, int)>(isLeaf: true);

  int epoll_create(
    int __size,
  ) {
    return _epoll_create(
      __size,
    );
  }

  late final _epoll_createPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('epoll_create');
  late final _epoll_create = _epoll_createPtr.asFunction<int Function(int)>(isLeaf: true);

  int epoll_create1(
    int __flags,
  ) {
    return _epoll_create1(
      __flags,
    );
  }

  late final _epoll_create1Ptr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('epoll_create1');
  late final _epoll_create1 = _epoll_create1Ptr.asFunction<int Function(int)>(isLeaf: true);

  int epoll_ctl(
    int __epfd,
    int __op,
    int __fd,
    ffi.Pointer<epoll_event> __event,
  ) {
    return _epoll_ctl(
      __epfd,
      __op,
      __fd,
      __event,
    );
  }

  late final _epoll_ctlPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<epoll_event>)>>('epoll_ctl');
  late final _epoll_ctl = _epoll_ctlPtr.asFunction<int Function(int, int, int, ffi.Pointer<epoll_event>)>(isLeaf: true);

  int epoll_wait(
    int __epfd,
    ffi.Pointer<epoll_event> __events,
    int __maxevents,
    int __timeout,
  ) {
    return _epoll_wait(
      __epfd,
      __events,
      __maxevents,
      __timeout,
    );
  }

  late final _epoll_waitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<epoll_event>, ffi.Int, ffi.Int)>>('epoll_wait');
  late final _epoll_wait = _epoll_waitPtr.asFunction<int Function(int, ffi.Pointer<epoll_event>, int, int)>();

  int eventfd(
    int __count,
    int __flags,
  ) {
    return _eventfd(
      __count,
      __flags,
    );
  }

  late final _eventfdPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt, ffi.Int)>>('eventfd');
  late final _eventfd = _eventfdPtr.asFunction<int Function(int, int)>(isLeaf: true);

  int cfgetospeed(
    ffi.Pointer<termios> __termios_p,
  ) {
    return _cfgetospeed(
      __termios_p,
    );
  }

  late final _cfgetospeedPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<termios>)>>('cfgetospeed');
  late final _cfgetospeed = _cfgetospeedPtr.asFunction<int Function(ffi.Pointer<termios>)>(isLeaf: true);

  int cfgetispeed(
    ffi.Pointer<termios> __termios_p,
  ) {
    return _cfgetispeed(
      __termios_p,
    );
  }

  late final _cfgetispeedPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<termios>)>>('cfgetispeed');
  late final _cfgetispeed = _cfgetispeedPtr.asFunction<int Function(ffi.Pointer<termios>)>(isLeaf: true);

  int cfsetospeed(
    ffi.Pointer<termios> __termios_p,
    int __speed,
  ) {
    return _cfsetospeed(
      __termios_p,
      __speed,
    );
  }

  late final _cfsetospeedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<termios>, ffi.UnsignedInt)>>('cfsetospeed');
  late final _cfsetospeed = _cfsetospeedPtr.asFunction<int Function(ffi.Pointer<termios>, int)>(isLeaf: true);

  int cfsetispeed(
    ffi.Pointer<termios> __termios_p,
    int __speed,
  ) {
    return _cfsetispeed(
      __termios_p,
      __speed,
    );
  }

  late final _cfsetispeedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<termios>, ffi.UnsignedInt)>>('cfsetispeed');
  late final _cfsetispeed = _cfsetispeedPtr.asFunction<int Function(ffi.Pointer<termios>, int)>(isLeaf: true);

  int tcgetattr(
    int __fd,
    ffi.Pointer<termios> __termios_p,
  ) {
    return _tcgetattr(
      __fd,
      __termios_p,
    );
  }

  late final _tcgetattrPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<termios>)>>('tcgetattr');
  late final _tcgetattr = _tcgetattrPtr.asFunction<int Function(int, ffi.Pointer<termios>)>(isLeaf: true);

  int tcsetattr(
    int __fd,
    int __optional_actions,
    ffi.Pointer<termios> __termios_p,
  ) {
    return _tcsetattr(
      __fd,
      __optional_actions,
      __termios_p,
    );
  }

  late final _tcsetattrPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Pointer<termios>)>>('tcsetattr');
  late final _tcsetattr = _tcsetattrPtr.asFunction<int Function(int, int, ffi.Pointer<termios>)>(isLeaf: true);

  int tcsendbreak(
    int __fd,
    int __duration,
  ) {
    return _tcsendbreak(
      __fd,
      __duration,
    );
  }

  late final _tcsendbreakPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('tcsendbreak');
  late final _tcsendbreak = _tcsendbreakPtr.asFunction<int Function(int, int)>(isLeaf: true);

  int tcdrain(
    int __fd,
  ) {
    return _tcdrain(
      __fd,
    );
  }

  late final _tcdrainPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('tcdrain');
  late final _tcdrain = _tcdrainPtr.asFunction<int Function(int)>(isLeaf: true);

  int tcflush(
    int __fd,
    int __queue_selector,
  ) {
    return _tcflush(
      __fd,
      __queue_selector,
    );
  }

  late final _tcflushPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('tcflush');
  late final _tcflush = _tcflushPtr.asFunction<int Function(int, int)>(isLeaf: true);

  int tcflow(
    int __fd,
    int __action,
  ) {
    return _tcflow(
      __fd,
      __action,
    );
  }

  late final _tcflowPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('tcflow');
  late final _tcflow = _tcflowPtr.asFunction<int Function(int, int)>(isLeaf: true);

  int tcgetsid(
    int __fd,
  ) {
    return _tcgetsid(
      __fd,
    );
  }

  late final _tcgetsidPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('tcgetsid');
  late final _tcgetsid = _tcgetsidPtr.asFunction<int Function(int)>(isLeaf: true);

  int socket(
    int __domain,
    int __type,
    int __protocol,
  ) {
    return _socket(
      __domain,
      __type,
      __protocol,
    );
  }

  late final _socketPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>('socket');
  late final _socket = _socketPtr.asFunction<int Function(int, int, int)>(isLeaf: true);

  int bind(
    int __fd,
    ffi.Pointer<sockaddr> __addr,
    int __len,
  ) {
    return _bind(
      __fd,
      __addr,
      __len,
    );
  }

  late final _bindPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<sockaddr>, ffi.UnsignedInt)>>('bind');
  late final _bind = _bindPtr.asFunction<int Function(int, ffi.Pointer<sockaddr>, int)>(isLeaf: true);

  int getsockname(
    int __fd,
    ffi.Pointer<sockaddr> __addr,
    ffi.Pointer<ffi.UnsignedInt> __len,
  ) {
    return _getsockname(
      __fd,
      __addr,
      __len,
    );
  }

  late final _getsocknamePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<sockaddr>, ffi.Pointer<ffi.UnsignedInt>)>>(
          'getsockname');
  late final _getsockname =
      _getsocknamePtr.asFunction<int Function(int, ffi.Pointer<sockaddr>, ffi.Pointer<ffi.UnsignedInt>)>(isLeaf: true);

  int send(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
    int __flags,
  ) {
    return _send(
      __fd,
      __buf,
      __n,
      __flags,
    );
  }

  late final _sendPtr =
      _lookup<ffi.NativeFunction<pkg_ssizet.SSize Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)>>('send');
  late final _send = _sendPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  int sendmsg(
    int __fd,
    ffi.Pointer<msghdr> __message,
    int __flags,
  ) {
    return _sendmsg(
      __fd,
      __message,
      __flags,
    );
  }

  late final _sendmsgPtr =
      _lookup<ffi.NativeFunction<pkg_ssizet.SSize Function(ffi.Int, ffi.Pointer<msghdr>, ffi.Int)>>('sendmsg');
  late final _sendmsg = _sendmsgPtr.asFunction<int Function(int, ffi.Pointer<msghdr>, int)>();

  int recvmsg(
    int __fd,
    ffi.Pointer<msghdr> __message,
    int __flags,
  ) {
    return _recvmsg(
      __fd,
      __message,
      __flags,
    );
  }

  late final _recvmsgPtr =
      _lookup<ffi.NativeFunction<pkg_ssizet.SSize Function(ffi.Int, ffi.Pointer<msghdr>, ffi.Int)>>('recvmsg');
  late final _recvmsg = _recvmsgPtr.asFunction<int Function(int, ffi.Pointer<msghdr>, int)>();

  int getsockopt(
    int __fd,
    int __level,
    int __optname,
    ffi.Pointer<ffi.Void> __optval,
    ffi.Pointer<ffi.UnsignedInt> __optlen,
  ) {
    return _getsockopt(
      __fd,
      __level,
      __optname,
      __optval,
      __optlen,
    );
  }

  late final _getsockoptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>)>>('getsockopt');
  late final _getsockopt = _getsockoptPtr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>)>(isLeaf: true);

  int setsockopt(
    int __fd,
    int __level,
    int __optname,
    ffi.Pointer<ffi.Void> __optval,
    int __optlen,
  ) {
    return _setsockopt(
      __fd,
      __level,
      __optname,
      __optval,
      __optlen,
    );
  }

  late final _setsockoptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>, ffi.UnsignedInt)>>(
          'setsockopt');
  late final _setsockopt =
      _setsockoptPtr.asFunction<int Function(int, int, int, ffi.Pointer<ffi.Void>, int)>(isLeaf: true);

  int if_nametoindex(
    ffi.Pointer<ffi.Char> __ifname,
  ) {
    return _if_nametoindex(
      __ifname,
    );
  }

  late final _if_nametoindexPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>)>>('if_nametoindex');
  late final _if_nametoindex = _if_nametoindexPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>(isLeaf: true);

  ffi.Pointer<ffi.Char> if_indextoname(
    int __ifindex,
    ffi.Pointer<ffi.Char> __ifname,
  ) {
    return _if_indextoname(
      __ifindex,
      __ifname,
    );
  }

  late final _if_indextonamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>)>>(
          'if_indextoname');
  late final _if_indextoname =
      _if_indextonamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>)>(isLeaf: true);

  ffi.Pointer<if_nameindex> if_nameindex1() {
    return _if_nameindex1();
  }

  late final _if_nameindex1Ptr = _lookup<ffi.NativeFunction<ffi.Pointer<if_nameindex> Function()>>('if_nameindex');
  late final _if_nameindex1 = _if_nameindex1Ptr.asFunction<ffi.Pointer<if_nameindex> Function()>(isLeaf: true);

  void if_freenameindex(
    ffi.Pointer<if_nameindex> __ptr,
  ) {
    return _if_freenameindex(
      __ptr,
    );
  }

  late final _if_freenameindexPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<if_nameindex>)>>('if_freenameindex');
  late final _if_freenameindex =
      _if_freenameindexPtr.asFunction<void Function(ffi.Pointer<if_nameindex>)>(isLeaf: true);

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final LibCAmd64 _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function()>> get errno_location => _library._errno_locationPtr;
  ffi.Pointer<ffi.NativeFunction<pkg_ssizet.SSize Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int)>> get read =>
      _library._readPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.UnsignedLong)>> get ioctl => _library._ioctlPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<epoll_event>)>>
      get epoll_ctl => _library._epoll_ctlPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<epoll_event>, ffi.Int, ffi.Int)>>
      get epoll_wait => _library._epoll_waitPtr;
}

abstract class EPOLL_EVENTS {
  static const int EPOLLIN = 1;
  static const int EPOLLPRI = 2;
  static const int EPOLLOUT = 4;
  static const int EPOLLRDNORM = 64;
  static const int EPOLLRDBAND = 128;
  static const int EPOLLWRNORM = 256;
  static const int EPOLLWRBAND = 512;
  static const int EPOLLMSG = 1024;
  static const int EPOLLERR = 8;
  static const int EPOLLHUP = 16;
  static const int EPOLLRDHUP = 8192;
  static const int EPOLLEXCLUSIVE = 268435456;
  static const int EPOLLWAKEUP = 536870912;
  static const int EPOLLONESHOT = 1073741824;
  static const int EPOLLET = -2147483648;
}

class epoll_data extends ffi.Union {
  external ffi.Pointer<ffi.Void> ptr;

  @ffi.Int()
  external int fd;

  @ffi.Uint32()
  external int u32;

  @ffi.Uint64()
  external int u64;
}

@ffi.Packed(1)
class epoll_event extends ffi.Struct {
  @ffi.Uint32()
  external int events;

  external epoll_data data;
}

/// struct gpiochip_info - Information about a certain GPIO chip
/// @name: the Linux kernel name of this GPIO chip
/// @label: a functional name for this GPIO chip, such as a product
/// number, may be empty (i.e. label[0] == '\0')
/// @lines: number of GPIO lines on this chip
class gpiochip_info extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> label;

  @ffi.Uint32()
  external int lines;
}

/// struct gpio_v2_line_values - Values of GPIO lines
/// @bits: a bitmap containing the value of the lines, set to 1 for active
/// and 0 for inactive.
/// @mask: a bitmap identifying the lines to get or set, with each bit
/// number corresponding to the index into &struct
/// gpio_v2_line_request.offsets.
class gpio_v2_line_values extends ffi.Struct {
  @ffi.Uint64()
  external int bits;

  @ffi.Uint64()
  external int mask;
}

/// struct gpio_v2_line_attribute - a configurable attribute of a line
/// @id: attribute identifier with value from &enum gpio_v2_line_attr_id
/// @padding: reserved for future use and must be zero filled
/// @flags: if id is %GPIO_V2_LINE_ATTR_ID_FLAGS, the flags for the GPIO
/// line, with values from &enum gpio_v2_line_flag, such as
/// %GPIO_V2_LINE_FLAG_ACTIVE_LOW, %GPIO_V2_LINE_FLAG_OUTPUT etc, added
/// together.  This overrides the default flags contained in the &struct
/// gpio_v2_line_config for the associated line.
/// @values: if id is %GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES, a bitmap
/// containing the values to which the lines will be set, with each bit
/// number corresponding to the index into &struct
/// gpio_v2_line_request.offsets.
/// @debounce_period_us: if id is %GPIO_V2_LINE_ATTR_ID_DEBOUNCE, the
/// desired debounce period, in microseconds
class gpio_v2_line_attribute extends ffi.Struct {
  @ffi.Uint32()
  external int id;

  @ffi.Uint32()
  external int padding;

  external UnnamedUnion1 unnamed;
}

class UnnamedUnion1 extends ffi.Union {
  @ffi.Uint64()
  external int flags;

  @ffi.Uint64()
  external int values;

  @ffi.Uint32()
  external int debounce_period_us;
}

/// struct gpio_v2_line_config_attribute - a configuration attribute
/// associated with one or more of the requested lines.
/// @attr: the configurable attribute
/// @mask: a bitmap identifying the lines to which the attribute applies,
/// with each bit number corresponding to the index into &struct
/// gpio_v2_line_request.offsets.
class gpio_v2_line_config_attribute extends ffi.Struct {
  external gpio_v2_line_attribute attr;

  @ffi.Uint64()
  external int mask;
}

/// struct gpio_v2_line_config - Configuration for GPIO lines
/// @flags: flags for the GPIO lines, with values from &enum
/// gpio_v2_line_flag, such as %GPIO_V2_LINE_FLAG_ACTIVE_LOW,
/// %GPIO_V2_LINE_FLAG_OUTPUT etc, added together.  This is the default for
/// all requested lines but may be overridden for particular lines using
/// @attrs.
/// @num_attrs: the number of attributes in @attrs
/// @padding: reserved for future use and must be zero filled
/// @attrs: the configuration attributes associated with the requested
/// lines.  Any attribute should only be associated with a particular line
/// once.  If an attribute is associated with a line multiple times then the
/// first occurrence (i.e. lowest index) has precedence.
class gpio_v2_line_config extends ffi.Struct {
  @ffi.Uint64()
  external int flags;

  @ffi.Uint32()
  external int num_attrs;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> padding;

  @ffi.Array.multi([10])
  external ffi.Array<gpio_v2_line_config_attribute> attrs;
}

/// struct gpio_v2_line_request - Information about a request for GPIO lines
/// @offsets: an array of desired lines, specified by offset index for the
/// associated GPIO chip
/// @consumer: a desired consumer label for the selected GPIO lines such as
/// "my-bitbanged-relay"
/// @config: requested configuration for the lines.
/// @num_lines: number of lines requested in this request, i.e. the number
/// of valid fields in the %GPIO_V2_LINES_MAX sized arrays, set to 1 to
/// request a single line
/// @event_buffer_size: a suggested minimum number of line events that the
/// kernel should buffer.  This is only relevant if edge detection is
/// enabled in the configuration. Note that this is only a suggested value
/// and the kernel may allocate a larger buffer or cap the size of the
/// buffer. If this field is zero then the buffer size defaults to a minimum
/// of @num_lines * 16.
/// @padding: reserved for future use and must be zero filled
/// @fd: if successful this field will contain a valid anonymous file handle
/// after a %GPIO_GET_LINE_IOCTL operation, zero or negative value means
/// error
class gpio_v2_line_request extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Uint32> offsets;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> consumer;

  external gpio_v2_line_config config;

  @ffi.Uint32()
  external int num_lines;

  @ffi.Uint32()
  external int event_buffer_size;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> padding;

  @ffi.Int32()
  external int fd;
}

/// struct gpio_v2_line_info - Information about a certain GPIO line
/// @name: the name of this GPIO line, such as the output pin of the line on
/// the chip, a rail or a pin header name on a board, as specified by the
/// GPIO chip, may be empty (i.e. name[0] == '\0')
/// @consumer: a functional name for the consumer of this GPIO line as set
/// by whatever is using it, will be empty if there is no current user but
/// may also be empty if the consumer doesn't set this up
/// @offset: the local offset on this GPIO chip, fill this in when
/// requesting the line information from the kernel
/// @num_attrs: the number of attributes in @attrs
/// @flags: flags for this GPIO line, with values from &enum
/// gpio_v2_line_flag, such as %GPIO_V2_LINE_FLAG_ACTIVE_LOW,
/// %GPIO_V2_LINE_FLAG_OUTPUT etc, added together.
/// @attrs: the configuration attributes associated with the line
/// @padding: reserved for future use
class gpio_v2_line_info extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> consumer;

  @ffi.Uint32()
  external int offset;

  @ffi.Uint32()
  external int num_attrs;

  @ffi.Uint64()
  external int flags;

  @ffi.Array.multi([10])
  external ffi.Array<gpio_v2_line_attribute> attrs;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> padding;
}

/// struct gpio_v2_line_event - The actual event being pushed to userspace
/// @timestamp_ns: best estimate of time of event occurrence, in nanoseconds.
/// @id: event identifier with value from &enum gpio_v2_line_event_id
/// @offset: the offset of the line that triggered the event
/// @seqno: the sequence number for this event in the sequence of events for
/// all the lines in this line request
/// @line_seqno: the sequence number for this event in the sequence of
/// events on this particular line
/// @padding: reserved for future use
///
/// By default the @timestamp_ns is read from %CLOCK_MONOTONIC and is
/// intended to allow the accurate measurement of the time between events.
/// It does not provide the wall-clock time.
///
/// If the %GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME flag is set then the
/// @timestamp_ns is read from %CLOCK_REALTIME.
class gpio_v2_line_event extends ffi.Struct {
  @ffi.Uint64()
  external int timestamp_ns;

  @ffi.Uint32()
  external int id;

  @ffi.Uint32()
  external int offset;

  @ffi.Uint32()
  external int seqno;

  @ffi.Uint32()
  external int line_seqno;

  @ffi.Array.multi([6])
  external ffi.Array<ffi.Uint32> padding;
}

/// struct gpioline_info - Information about a certain GPIO line
/// @line_offset: the local offset on this GPIO device, fill this in when
/// requesting the line information from the kernel
/// @flags: various flags for this line
/// @name: the name of this GPIO line, such as the output pin of the line on the
/// chip, a rail or a pin header name on a board, as specified by the gpio
/// chip, may be empty (i.e. name[0] == '\0')
/// @consumer: a functional name for the consumer of this GPIO line as set by
/// whatever is using it, will be empty if there is no current user but may
/// also be empty if the consumer doesn't set this up
///
/// Note: This struct is part of ABI v1 and is deprecated.
/// Use &struct gpio_v2_line_info instead.
class gpioline_info extends ffi.Struct {
  @ffi.Uint32()
  external int line_offset;

  @ffi.Uint32()
  external int flags;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> consumer;
}

/// struct gpioline_info_changed - Information about a change in status
/// of a GPIO line
/// @info: updated line information
/// @timestamp: estimate of time of status change occurrence, in nanoseconds
/// @event_type: one of %GPIOLINE_CHANGED_REQUESTED,
/// %GPIOLINE_CHANGED_RELEASED and %GPIOLINE_CHANGED_CONFIG
/// @padding: reserved for future use
///
/// The &struct gpioline_info embedded here has 32-bit alignment on its own,
/// but it works fine with 64-bit alignment too. With its 72 byte size, we can
/// guarantee there are no implicit holes between it and subsequent members.
/// The 20-byte padding at the end makes sure we don't add any implicit padding
/// at the end of the structure on 64-bit architectures.
///
/// Note: This struct is part of ABI v1 and is deprecated.
/// Use &struct gpio_v2_line_info_changed instead.
class gpioline_info_changed extends ffi.Struct {
  external gpioline_info info;

  @ffi.Uint64()
  external int timestamp;

  @ffi.Uint32()
  external int event_type;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> padding;
}

/// struct gpiohandle_request - Information about a GPIO handle request
/// @lineoffsets: an array of desired lines, specified by offset index for the
/// associated GPIO device
/// @flags: desired flags for the desired GPIO lines, such as
/// %GPIOHANDLE_REQUEST_OUTPUT, %GPIOHANDLE_REQUEST_ACTIVE_LOW etc, added
/// together. Note that even if multiple lines are requested, the same flags
/// must be applicable to all of them, if you want lines with individual
/// flags set, request them one by one. It is possible to select
/// a batch of input or output lines, but they must all have the same
/// characteristics, i.e. all inputs or all outputs, all active low etc
/// @default_values: if the %GPIOHANDLE_REQUEST_OUTPUT is set for a requested
/// line, this specifies the default output value, should be 0 (low) or
/// 1 (high), anything else than 0 or 1 will be interpreted as 1 (high)
/// @consumer_label: a desired consumer label for the selected GPIO line(s)
/// such as "my-bitbanged-relay"
/// @lines: number of lines requested in this request, i.e. the number of
/// valid fields in the above arrays, set to 1 to request a single line
/// @fd: if successful this field will contain a valid anonymous file handle
/// after a %GPIO_GET_LINEHANDLE_IOCTL operation, zero or negative value
/// means error
///
/// Note: This struct is part of ABI v1 and is deprecated.
/// Use &struct gpio_v2_line_request instead.
class gpiohandle_request extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Uint32> lineoffsets;

  @ffi.Uint32()
  external int flags;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.Uint8> default_values;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> consumer_label;

  @ffi.Uint32()
  external int lines;

  @ffi.Int()
  external int fd;
}

/// struct gpiohandle_config - Configuration for a GPIO handle request
/// @flags: updated flags for the requested GPIO lines, such as
/// %GPIOHANDLE_REQUEST_OUTPUT, %GPIOHANDLE_REQUEST_ACTIVE_LOW etc, added
/// together
/// @default_values: if the %GPIOHANDLE_REQUEST_OUTPUT is set in flags,
/// this specifies the default output value, should be 0 (low) or
/// 1 (high), anything else than 0 or 1 will be interpreted as 1 (high)
/// @padding: reserved for future use and should be zero filled
///
/// Note: This struct is part of ABI v1 and is deprecated.
/// Use &struct gpio_v2_line_config instead.
class gpiohandle_config extends ffi.Struct {
  @ffi.Uint32()
  external int flags;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.Uint8> default_values;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> padding;
}

/// struct gpiohandle_data - Information of values on a GPIO handle
/// @values: when getting the state of lines this contains the current
/// state of a line, when setting the state of lines these should contain
/// the desired target state
///
/// Note: This struct is part of ABI v1 and is deprecated.
/// Use &struct gpio_v2_line_values instead.
class gpiohandle_data extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Uint8> values;
}

/// struct gpioevent_request - Information about a GPIO event request
/// @lineoffset: the desired line to subscribe to events from, specified by
/// offset index for the associated GPIO device
/// @handleflags: desired handle flags for the desired GPIO line, such as
/// %GPIOHANDLE_REQUEST_ACTIVE_LOW or %GPIOHANDLE_REQUEST_OPEN_DRAIN
/// @eventflags: desired flags for the desired GPIO event line, such as
/// %GPIOEVENT_REQUEST_RISING_EDGE or %GPIOEVENT_REQUEST_FALLING_EDGE
/// @consumer_label: a desired consumer label for the selected GPIO line(s)
/// such as "my-listener"
/// @fd: if successful this field will contain a valid anonymous file handle
/// after a %GPIO_GET_LINEEVENT_IOCTL operation, zero or negative value
/// means error
///
/// Note: This struct is part of ABI v1 and is deprecated.
/// Use &struct gpio_v2_line_request instead.
class gpioevent_request extends ffi.Struct {
  @ffi.Uint32()
  external int lineoffset;

  @ffi.Uint32()
  external int handleflags;

  @ffi.Uint32()
  external int eventflags;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> consumer_label;

  @ffi.Int()
  external int fd;
}

/// struct gpioevent_data - The actual event being pushed to userspace
/// @timestamp: best estimate of time of event occurrence, in nanoseconds
/// @id: event identifier
///
/// Note: This struct is part of ABI v1 and is deprecated.
/// Use &struct gpio_v2_line_event instead.
class gpioevent_data extends ffi.Struct {
  @ffi.Uint64()
  external int timestamp;

  @ffi.Uint32()
  external int id;
}

class termios extends ffi.Struct {
  @ffi.UnsignedInt()
  external int c_iflag;

  @ffi.UnsignedInt()
  external int c_oflag;

  @ffi.UnsignedInt()
  external int c_cflag;

  @ffi.UnsignedInt()
  external int c_lflag;

  @ffi.UnsignedChar()
  external int c_line;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.UnsignedChar> c_cc;

  @ffi.UnsignedInt()
  external int c_ispeed;

  @ffi.UnsignedInt()
  external int c_ospeed;
}

/// struct spi_ioc_transfer - describes a single SPI transfer
/// @tx_buf: Holds pointer to userspace buffer with transmit data, or null.
/// If no data is provided, zeroes are shifted out.
/// @rx_buf: Holds pointer to userspace buffer for receive data, or null.
/// @len: Length of tx and rx buffers, in bytes.
/// @speed_hz: Temporary override of the device's bitrate.
/// @bits_per_word: Temporary override of the device's wordsize.
/// @delay_usecs: If nonzero, how long to delay after the last bit transfer
/// before optionally deselecting the device before the next transfer.
/// @cs_change: True to deselect device before starting the next transfer.
/// @word_delay_usecs: If nonzero, how long to wait between words within one
/// transfer. This property needs explicit support in the SPI controller,
/// otherwise it is silently ignored.
///
/// This structure is mapped directly to the kernel spi_transfer structure;
/// the fields have the same meanings, except of course that the pointers
/// are in a different address space (and may be of different sizes in some
/// cases, such as 32-bit i386 userspace over a 64-bit x86_64 kernel).
/// Zero-initialize the structure, including currently unused fields, to
/// accommodate potential future updates.
///
/// SPI_IOC_MESSAGE gives userspace the equivalent of kernel spi_sync().
/// Pass it an array of related transfers, they'll execute together.
/// Each transfer may be half duplex (either direction) or full duplex.
///
/// struct spi_ioc_transfer mesg[4];
/// ...
/// status = ioctl(fd, SPI_IOC_MESSAGE(4), mesg);
///
/// So for example one transfer might send a nine bit command (right aligned
/// in a 16-bit word), the next could read a block of 8-bit data before
/// terminating that command by temporarily deselecting the chip; the next
/// could send a different nine bit command (re-selecting the chip), and the
/// last transfer might write some register values.
class spi_ioc_transfer extends ffi.Struct {
  @ffi.Uint64()
  external int tx_buf;

  @ffi.Uint64()
  external int rx_buf;

  @ffi.Uint32()
  external int len;

  @ffi.Uint32()
  external int speed_hz;

  @ffi.Uint16()
  external int delay_usecs;

  @ffi.Uint8()
  external int bits_per_word;

  @ffi.Uint8()
  external int cs_change;

  @ffi.Uint8()
  external int tx_nbits;

  @ffi.Uint8()
  external int rx_nbits;

  @ffi.Uint8()
  external int word_delay_usecs;

  @ffi.Uint8()
  external int pad;
}

class iovec extends ffi.Struct {
  external ffi.Pointer<ffi.Void> iov_base;

  @ffi.Int()
  external int iov_len;
}

class sockaddr extends ffi.Struct {
  @ffi.UnsignedShort()
  external int sa_family;

  @ffi.Array.multi([14])
  external ffi.Array<ffi.Char> sa_data;
}

class msghdr extends ffi.Struct {
  external ffi.Pointer<ffi.Void> msg_name;

  @ffi.UnsignedInt()
  external int msg_namelen;

  external ffi.Pointer<iovec> msg_iov;

  @ffi.Int()
  external int msg_iovlen;

  external ffi.Pointer<ffi.Void> msg_control;

  @ffi.Int()
  external int msg_controllen;

  @ffi.Int()
  external int msg_flags;
}

class if_nameindex extends ffi.Struct {
  @ffi.UnsignedInt()
  external int if_index;

  external ffi.Pointer<ffi.Char> if_name;
}

class ifreq extends ffi.Struct {
  external UnnamedUnion2 ifr_ifrn;

  external UnnamedUnion3 ifr_ifru;
}

class UnnamedUnion2 extends ffi.Union {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> ifrn_name;
}

class UnnamedUnion3 extends ffi.Union {
  external sockaddr ifru_addr;

  external sockaddr ifru_dstaddr;

  external sockaddr ifru_broadaddr;

  external sockaddr ifru_netmask;

  external sockaddr ifru_hwaddr;

  @ffi.Short()
  external int ifru_flags;

  @ffi.Int()
  external int ifru_ivalue;

  @ffi.Int()
  external int ifru_mtu;

  external ifmap ifru_map;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> ifru_slave;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> ifru_newname;

  external ffi.Pointer<ffi.Char> ifru_data;
}

class ifmap extends ffi.Struct {
  @ffi.UnsignedLong()
  external int mem_start;

  @ffi.UnsignedLong()
  external int mem_end;

  @ffi.UnsignedShort()
  external int base_addr;

  @ffi.UnsignedChar()
  external int irq;

  @ffi.UnsignedChar()
  external int dma;

  @ffi.UnsignedChar()
  external int port;
}

/// struct can_frame - Classical CAN frame structure (aka CAN 2.0B)
/// @can_id:   CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
/// @len:      CAN frame payload length in byte (0 .. 8)
/// @can_dlc:  deprecated name for CAN frame payload length in byte (0 .. 8)
/// @__pad:    padding
/// @__res0:   reserved / padding
/// @len8_dlc: optional DLC value (9 .. 15) at 8 byte payload length
/// len8_dlc contains values from 9 .. 15 when the payload length is
/// 8 bytes but the DLC value (see ISO 11898-1) is greater then 8.
/// CAN_CTRLMODE_CC_LEN8_DLC flag has to be enabled in CAN driver.
/// @data:     CAN frame payload (up to 8 byte)
class can_frame extends ffi.Struct {
  @ffi.Uint32()
  external int can_id;

  external UnnamedUnion4 unnamed;

  @ffi.Uint8()
  external int __pad;

  @ffi.Uint8()
  external int __res0;

  @ffi.Uint8()
  external int len8_dlc;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint8> data;
}

class UnnamedUnion4 extends ffi.Union {
  @ffi.Uint8()
  external int len;

  @ffi.Uint8()
  external int can_dlc;
}

/// struct canfd_frame - CAN flexible data rate frame structure
/// @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
/// @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)
/// @flags:  additional flags for CAN FD
/// @__res0: reserved / padding
/// @__res1: reserved / padding
/// @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)
class canfd_frame extends ffi.Struct {
  @ffi.Uint32()
  external int can_id;

  @ffi.Uint8()
  external int len;

  @ffi.Uint8()
  external int flags;

  @ffi.Uint8()
  external int __res0;

  @ffi.Uint8()
  external int __res1;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.Uint8> data;
}

/// struct sockaddr_can - the sockaddr structure for CAN sockets
/// @can_family:  address family number AF_CAN.
/// @can_ifindex: CAN network interface index.
/// @can_addr:    protocol specific address information
class sockaddr_can extends ffi.Struct {
  @ffi.UnsignedShort()
  external int can_family;

  @ffi.Int()
  external int can_ifindex;

  external UnnamedUnion5 can_addr;
}

class UnnamedUnion5 extends ffi.Union {
  external UnnamedStruct1 tp;

  external UnnamedStruct2 j1939;
}

class UnnamedStruct1 extends ffi.Struct {
  @ffi.Uint32()
  external int rx_id;

  @ffi.Uint32()
  external int tx_id;
}

class UnnamedStruct2 extends ffi.Struct {
  @ffi.Uint64()
  external int name;

  @ffi.Uint32()
  external int pgn;

  @ffi.Uint8()
  external int addr;
}

/// struct can_filter - CAN ID based filter in can_register().
/// @can_id:   relevant bits of CAN ID which are not masked out.
/// @can_mask: CAN mask (see description)
///
/// Description:
/// A filter matches, when
///
/// <received_can_id> & mask == can_id & mask
///
/// The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
/// filter for error message frames (CAN_ERR_FLAG bit set in mask).
class can_filter extends ffi.Struct {
  @ffi.Uint32()
  external int can_id;

  @ffi.Uint32()
  external int can_mask;
}

class sockaddr_nl extends ffi.Struct {
  @ffi.UnsignedShort()
  external int nl_family;

  @ffi.UnsignedShort()
  external int nl_pad;

  @ffi.Uint32()
  external int nl_pid;

  @ffi.Uint32()
  external int nl_groups;
}

/// struct nlmsghdr - fixed format metadata header of Netlink messages
/// @nlmsg_len:   Length of message including header
/// @nlmsg_type:  Message content type
/// @nlmsg_flags: Additional flags
/// @nlmsg_seq:   Sequence number
/// @nlmsg_pid:   Sending process port ID
class nlmsghdr extends ffi.Struct {
  @ffi.Uint32()
  external int nlmsg_len;

  @ffi.Uint16()
  external int nlmsg_type;

  @ffi.Uint16()
  external int nlmsg_flags;

  @ffi.Uint32()
  external int nlmsg_seq;

  @ffi.Uint32()
  external int nlmsg_pid;
}

class nlmsgerr extends ffi.Struct {
  @ffi.Int()
  external int error;

  external nlmsghdr msg;
}

class rtattr extends ffi.Struct {
  @ffi.UnsignedShort()
  external int rta_len;

  @ffi.UnsignedShort()
  external int rta_type;
}

/// Definitions used in routing table administration.
class rtmsg extends ffi.Struct {
  @ffi.UnsignedChar()
  external int rtm_family;

  @ffi.UnsignedChar()
  external int rtm_dst_len;

  @ffi.UnsignedChar()
  external int rtm_src_len;

  @ffi.UnsignedChar()
  external int rtm_tos;

  @ffi.UnsignedChar()
  external int rtm_table;

  @ffi.UnsignedChar()
  external int rtm_protocol;

  @ffi.UnsignedChar()
  external int rtm_scope;

  @ffi.UnsignedChar()
  external int rtm_type;

  @ffi.UnsignedInt()
  external int rtm_flags;
}

/// Link layer specific messages.
class ifinfomsg extends ffi.Struct {
  @ffi.UnsignedChar()
  external int ifi_family;

  @ffi.UnsignedChar()
  external int __ifi_pad;

  @ffi.UnsignedShort()
  external int ifi_type;

  @ffi.Int()
  external int ifi_index;

  @ffi.UnsignedInt()
  external int ifi_flags;

  @ffi.UnsignedInt()
  external int ifi_change;
}

class can_bittiming extends ffi.Struct {
  @ffi.Uint32()
  external int bitrate;

  @ffi.Uint32()
  external int sample_point;

  @ffi.Uint32()
  external int tq;

  @ffi.Uint32()
  external int prop_seg;

  @ffi.Uint32()
  external int phase_seg1;

  @ffi.Uint32()
  external int phase_seg2;

  @ffi.Uint32()
  external int sjw;

  @ffi.Uint32()
  external int brp;
}

class can_bittiming_const extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> name;

  @ffi.Uint32()
  external int tseg1_min;

  @ffi.Uint32()
  external int tseg1_max;

  @ffi.Uint32()
  external int tseg2_min;

  @ffi.Uint32()
  external int tseg2_max;

  @ffi.Uint32()
  external int sjw_max;

  @ffi.Uint32()
  external int brp_min;

  @ffi.Uint32()
  external int brp_max;

  @ffi.Uint32()
  external int brp_inc;
}

class can_clock extends ffi.Struct {
  @ffi.Uint32()
  external int freq;
}

abstract class can_state {
  static const int CAN_STATE_ERROR_ACTIVE = 0;
  static const int CAN_STATE_ERROR_WARNING = 1;
  static const int CAN_STATE_ERROR_PASSIVE = 2;
  static const int CAN_STATE_BUS_OFF = 3;
  static const int CAN_STATE_STOPPED = 4;
  static const int CAN_STATE_SLEEPING = 5;
  static const int CAN_STATE_MAX = 6;
}

class can_berr_counter extends ffi.Struct {
  @ffi.Uint16()
  external int txerr;

  @ffi.Uint16()
  external int rxerr;
}

class can_ctrlmode extends ffi.Struct {
  @ffi.Uint32()
  external int mask;

  @ffi.Uint32()
  external int flags;
}

class can_device_stats extends ffi.Struct {
  @ffi.Uint32()
  external int bus_error;

  @ffi.Uint32()
  external int error_warning;

  @ffi.Uint32()
  external int error_passive;

  @ffi.Uint32()
  external int bus_off;

  @ffi.Uint32()
  external int arbitration_lost;

  @ffi.Uint32()
  external int restarts;
}

const int EPOLL_CLOEXEC = 524288;

const int GPIOLINE_CHANGED_REQUESTED = 1;

const int GPIOLINE_CHANGED_RELEASED = 2;

const int GPIOLINE_CHANGED_CONFIG = 3;

const int CAN_RAW_FILTER = 1;

const int CAN_RAW_ERR_FILTER = 2;

const int CAN_RAW_LOOPBACK = 3;

const int CAN_RAW_RECV_OWN_MSGS = 4;

const int CAN_RAW_FD_FRAMES = 5;

const int CAN_RAW_JOIN_FILTERS = 6;

const int CAN_RAW_XL_FRAMES = 7;

const int IFLA_UNSPEC = 0;

const int IFLA_ADDRESS = 1;

const int IFLA_BROADCAST = 2;

const int IFLA_IFNAME = 3;

const int IFLA_MTU = 4;

const int IFLA_LINK = 5;

const int IFLA_QDISC = 6;

const int IFLA_STATS = 7;

const int IFLA_COST = 8;

const int IFLA_PRIORITY = 9;

const int IFLA_MASTER = 10;

const int IFLA_WIRELESS = 11;

const int IFLA_PROTINFO = 12;

const int IFLA_TXQLEN = 13;

const int IFLA_MAP = 14;

const int IFLA_WEIGHT = 15;

const int IFLA_OPERSTATE = 16;

const int IFLA_LINKMODE = 17;

const int IFLA_LINKINFO = 18;

const int IFLA_NET_NS_PID = 19;

const int IFLA_IFALIAS = 20;

const int IFLA_NUM_VF = 21;

const int IFLA_VFINFO_LIST = 22;

const int IFLA_STATS64 = 23;

const int IFLA_VF_PORTS = 24;

const int IFLA_PORT_SELF = 25;

const int IFLA_AF_SPEC = 26;

const int IFLA_GROUP = 27;

const int IFLA_NET_NS_FD = 28;

const int IFLA_EXT_MASK = 29;

const int IFLA_PROMISCUITY = 30;

const int IFLA_NUM_TX_QUEUES = 31;

const int IFLA_NUM_RX_QUEUES = 32;

const int IFLA_CARRIER = 33;

const int IFLA_PHYS_PORT_ID = 34;

const int IFLA_CARRIER_CHANGES = 35;

const int IFLA_PHYS_SWITCH_ID = 36;

const int IFLA_LINK_NETNSID = 37;

const int IFLA_PHYS_PORT_NAME = 38;

const int IFLA_PROTO_DOWN = 39;

const int IFLA_GSO_MAX_SEGS = 40;

const int IFLA_GSO_MAX_SIZE = 41;

const int IFLA_PAD = 42;

const int IFLA_XDP = 43;

const int IFLA_EVENT = 44;

const int IFLA_NEW_NETNSID = 45;

const int IFLA_IF_NETNSID = 46;

const int IFLA_TARGET_NETNSID = 46;

const int IFLA_CARRIER_UP_COUNT = 47;

const int IFLA_CARRIER_DOWN_COUNT = 48;

const int IFLA_NEW_IFINDEX = 49;

const int IFLA_MIN_MTU = 50;

const int IFLA_MAX_MTU = 51;

const int IFLA_PROP_LIST = 52;

const int IFLA_ALT_IFNAME = 53;

const int IFLA_PERM_ADDRESS = 54;

const int IFLA_PROTO_DOWN_REASON = 55;

const int IFLA_PARENT_DEV_NAME = 56;

const int IFLA_PARENT_DEV_BUS_NAME = 57;

const int IFLA_GRO_MAX_SIZE = 58;

const int IFLA_TSO_MAX_SIZE = 59;

const int IFLA_TSO_MAX_SEGS = 60;

const int IFLA_ALLMULTI = 61;

const int IFLA_DEVLINK_PORT = 62;

const int IFLA_GSO_IPV4_MAX_SIZE = 63;

const int IFLA_GRO_IPV4_MAX_SIZE = 64;

const int IFLA_PROTO_DOWN_REASON_UNSPEC = 0;

const int IFLA_PROTO_DOWN_REASON_MASK = 1;

const int IFLA_PROTO_DOWN_REASON_VALUE = 2;

const int IFLA_PROTO_DOWN_REASON_MAX = 2;

const int IFLA_INET_UNSPEC = 0;

const int IFLA_INET_CONF = 1;

const int IFLA_INET6_UNSPEC = 0;

const int IFLA_INET6_FLAGS = 1;

const int IFLA_INET6_CONF = 2;

const int IFLA_INET6_STATS = 3;

const int IFLA_INET6_MCAST = 4;

const int IFLA_INET6_CACHEINFO = 5;

const int IFLA_INET6_ICMP6STATS = 6;

const int IFLA_INET6_TOKEN = 7;

const int IFLA_INET6_ADDR_GEN_MODE = 8;

const int IFLA_INET6_RA_MTU = 9;

const int IFLA_BR_UNSPEC = 0;

const int IFLA_BR_FORWARD_DELAY = 1;

const int IFLA_BR_HELLO_TIME = 2;

const int IFLA_BR_MAX_AGE = 3;

const int IFLA_BR_AGEING_TIME = 4;

const int IFLA_BR_STP_STATE = 5;

const int IFLA_BR_PRIORITY = 6;

const int IFLA_BR_VLAN_FILTERING = 7;

const int IFLA_BR_VLAN_PROTOCOL = 8;

const int IFLA_BR_GROUP_FWD_MASK = 9;

const int IFLA_BR_ROOT_ID = 10;

const int IFLA_BR_BRIDGE_ID = 11;

const int IFLA_BR_ROOT_PORT = 12;

const int IFLA_BR_ROOT_PATH_COST = 13;

const int IFLA_BR_TOPOLOGY_CHANGE = 14;

const int IFLA_BR_TOPOLOGY_CHANGE_DETECTED = 15;

const int IFLA_BR_HELLO_TIMER = 16;

const int IFLA_BR_TCN_TIMER = 17;

const int IFLA_BR_TOPOLOGY_CHANGE_TIMER = 18;

const int IFLA_BR_GC_TIMER = 19;

const int IFLA_BR_GROUP_ADDR = 20;

const int IFLA_BR_FDB_FLUSH = 21;

const int IFLA_BR_MCAST_ROUTER = 22;

const int IFLA_BR_MCAST_SNOOPING = 23;

const int IFLA_BR_MCAST_QUERY_USE_IFADDR = 24;

const int IFLA_BR_MCAST_QUERIER = 25;

const int IFLA_BR_MCAST_HASH_ELASTICITY = 26;

const int IFLA_BR_MCAST_HASH_MAX = 27;

const int IFLA_BR_MCAST_LAST_MEMBER_CNT = 28;

const int IFLA_BR_MCAST_STARTUP_QUERY_CNT = 29;

const int IFLA_BR_MCAST_LAST_MEMBER_INTVL = 30;

const int IFLA_BR_MCAST_MEMBERSHIP_INTVL = 31;

const int IFLA_BR_MCAST_QUERIER_INTVL = 32;

const int IFLA_BR_MCAST_QUERY_INTVL = 33;

const int IFLA_BR_MCAST_QUERY_RESPONSE_INTVL = 34;

const int IFLA_BR_MCAST_STARTUP_QUERY_INTVL = 35;

const int IFLA_BR_NF_CALL_IPTABLES = 36;

const int IFLA_BR_NF_CALL_IP6TABLES = 37;

const int IFLA_BR_NF_CALL_ARPTABLES = 38;

const int IFLA_BR_VLAN_DEFAULT_PVID = 39;

const int IFLA_BR_PAD = 40;

const int IFLA_BR_VLAN_STATS_ENABLED = 41;

const int IFLA_BR_MCAST_STATS_ENABLED = 42;

const int IFLA_BR_MCAST_IGMP_VERSION = 43;

const int IFLA_BR_MCAST_MLD_VERSION = 44;

const int IFLA_BR_VLAN_STATS_PER_PORT = 45;

const int IFLA_BR_MULTI_BOOLOPT = 46;

const int IFLA_BR_MCAST_QUERIER_STATE = 47;

const int IFLA_BRPORT_UNSPEC = 0;

const int IFLA_BRPORT_STATE = 1;

const int IFLA_BRPORT_PRIORITY = 2;

const int IFLA_BRPORT_COST = 3;

const int IFLA_BRPORT_MODE = 4;

const int IFLA_BRPORT_GUARD = 5;

const int IFLA_BRPORT_PROTECT = 6;

const int IFLA_BRPORT_FAST_LEAVE = 7;

const int IFLA_BRPORT_LEARNING = 8;

const int IFLA_BRPORT_UNICAST_FLOOD = 9;

const int IFLA_BRPORT_PROXYARP = 10;

const int IFLA_BRPORT_LEARNING_SYNC = 11;

const int IFLA_BRPORT_PROXYARP_WIFI = 12;

const int IFLA_BRPORT_ROOT_ID = 13;

const int IFLA_BRPORT_BRIDGE_ID = 14;

const int IFLA_BRPORT_DESIGNATED_PORT = 15;

const int IFLA_BRPORT_DESIGNATED_COST = 16;

const int IFLA_BRPORT_ID = 17;

const int IFLA_BRPORT_NO = 18;

const int IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19;

const int IFLA_BRPORT_CONFIG_PENDING = 20;

const int IFLA_BRPORT_MESSAGE_AGE_TIMER = 21;

const int IFLA_BRPORT_FORWARD_DELAY_TIMER = 22;

const int IFLA_BRPORT_HOLD_TIMER = 23;

const int IFLA_BRPORT_FLUSH = 24;

const int IFLA_BRPORT_MULTICAST_ROUTER = 25;

const int IFLA_BRPORT_PAD = 26;

const int IFLA_BRPORT_MCAST_FLOOD = 27;

const int IFLA_BRPORT_MCAST_TO_UCAST = 28;

const int IFLA_BRPORT_VLAN_TUNNEL = 29;

const int IFLA_BRPORT_BCAST_FLOOD = 30;

const int IFLA_BRPORT_GROUP_FWD_MASK = 31;

const int IFLA_BRPORT_NEIGH_SUPPRESS = 32;

const int IFLA_BRPORT_ISOLATED = 33;

const int IFLA_BRPORT_BACKUP_PORT = 34;

const int IFLA_BRPORT_MRP_RING_OPEN = 35;

const int IFLA_BRPORT_MRP_IN_OPEN = 36;

const int IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT = 37;

const int IFLA_BRPORT_MCAST_EHT_HOSTS_CNT = 38;

const int IFLA_BRPORT_LOCKED = 39;

const int IFLA_BRPORT_MAB = 40;

const int IFLA_BRPORT_MCAST_N_GROUPS = 41;

const int IFLA_BRPORT_MCAST_MAX_GROUPS = 42;

const int IFLA_INFO_UNSPEC = 0;

const int IFLA_INFO_KIND = 1;

const int IFLA_INFO_DATA = 2;

const int IFLA_INFO_XSTATS = 3;

const int IFLA_INFO_SLAVE_KIND = 4;

const int IFLA_INFO_SLAVE_DATA = 5;

const int IFLA_VLAN_UNSPEC = 0;

const int IFLA_VLAN_ID = 1;

const int IFLA_VLAN_FLAGS = 2;

const int IFLA_VLAN_EGRESS_QOS = 3;

const int IFLA_VLAN_INGRESS_QOS = 4;

const int IFLA_VLAN_PROTOCOL = 5;

const int IFLA_VLAN_QOS_UNSPEC = 0;

const int IFLA_VLAN_QOS_MAPPING = 1;

const int IFLA_MACVLAN_UNSPEC = 0;

const int IFLA_MACVLAN_MODE = 1;

const int IFLA_MACVLAN_FLAGS = 2;

const int IFLA_MACVLAN_MACADDR_MODE = 3;

const int IFLA_MACVLAN_MACADDR = 4;

const int IFLA_MACVLAN_MACADDR_DATA = 5;

const int IFLA_MACVLAN_MACADDR_COUNT = 6;

const int IFLA_MACVLAN_BC_QUEUE_LEN = 7;

const int IFLA_MACVLAN_BC_QUEUE_LEN_USED = 8;

const int IFLA_VRF_UNSPEC = 0;

const int IFLA_VRF_TABLE = 1;

const int IFLA_VRF_PORT_UNSPEC = 0;

const int IFLA_VRF_PORT_TABLE = 1;

const int IFLA_MACSEC_UNSPEC = 0;

const int IFLA_MACSEC_SCI = 1;

const int IFLA_MACSEC_PORT = 2;

const int IFLA_MACSEC_ICV_LEN = 3;

const int IFLA_MACSEC_CIPHER_SUITE = 4;

const int IFLA_MACSEC_WINDOW = 5;

const int IFLA_MACSEC_ENCODING_SA = 6;

const int IFLA_MACSEC_ENCRYPT = 7;

const int IFLA_MACSEC_PROTECT = 8;

const int IFLA_MACSEC_INC_SCI = 9;

const int IFLA_MACSEC_ES = 10;

const int IFLA_MACSEC_SCB = 11;

const int IFLA_MACSEC_REPLAY_PROTECT = 12;

const int IFLA_MACSEC_VALIDATION = 13;

const int IFLA_MACSEC_PAD = 14;

const int IFLA_MACSEC_OFFLOAD = 15;

const int IFLA_XFRM_UNSPEC = 0;

const int IFLA_XFRM_LINK = 1;

const int IFLA_XFRM_IF_ID = 2;

const int IFLA_XFRM_COLLECT_METADATA = 3;

const int IFLA_IPVLAN_UNSPEC = 0;

const int IFLA_IPVLAN_MODE = 1;

const int IFLA_IPVLAN_FLAGS = 2;

const int IFLA_VXLAN_UNSPEC = 0;

const int IFLA_VXLAN_ID = 1;

const int IFLA_VXLAN_GROUP = 2;

const int IFLA_VXLAN_LINK = 3;

const int IFLA_VXLAN_LOCAL = 4;

const int IFLA_VXLAN_TTL = 5;

const int IFLA_VXLAN_TOS = 6;

const int IFLA_VXLAN_LEARNING = 7;

const int IFLA_VXLAN_AGEING = 8;

const int IFLA_VXLAN_LIMIT = 9;

const int IFLA_VXLAN_PORT_RANGE = 10;

const int IFLA_VXLAN_PROXY = 11;

const int IFLA_VXLAN_RSC = 12;

const int IFLA_VXLAN_L2MISS = 13;

const int IFLA_VXLAN_L3MISS = 14;

const int IFLA_VXLAN_PORT = 15;

const int IFLA_VXLAN_GROUP6 = 16;

const int IFLA_VXLAN_LOCAL6 = 17;

const int IFLA_VXLAN_UDP_CSUM = 18;

const int IFLA_VXLAN_UDP_ZERO_CSUM6_TX = 19;

const int IFLA_VXLAN_UDP_ZERO_CSUM6_RX = 20;

const int IFLA_VXLAN_REMCSUM_TX = 21;

const int IFLA_VXLAN_REMCSUM_RX = 22;

const int IFLA_VXLAN_GBP = 23;

const int IFLA_VXLAN_REMCSUM_NOPARTIAL = 24;

const int IFLA_VXLAN_COLLECT_METADATA = 25;

const int IFLA_VXLAN_LABEL = 26;

const int IFLA_VXLAN_GPE = 27;

const int IFLA_VXLAN_TTL_INHERIT = 28;

const int IFLA_VXLAN_DF = 29;

const int IFLA_VXLAN_VNIFILTER = 30;

const int IFLA_GENEVE_UNSPEC = 0;

const int IFLA_GENEVE_ID = 1;

const int IFLA_GENEVE_REMOTE = 2;

const int IFLA_GENEVE_TTL = 3;

const int IFLA_GENEVE_TOS = 4;

const int IFLA_GENEVE_PORT = 5;

const int IFLA_GENEVE_COLLECT_METADATA = 6;

const int IFLA_GENEVE_REMOTE6 = 7;

const int IFLA_GENEVE_UDP_CSUM = 8;

const int IFLA_GENEVE_UDP_ZERO_CSUM6_TX = 9;

const int IFLA_GENEVE_UDP_ZERO_CSUM6_RX = 10;

const int IFLA_GENEVE_LABEL = 11;

const int IFLA_GENEVE_TTL_INHERIT = 12;

const int IFLA_GENEVE_DF = 13;

const int IFLA_GENEVE_INNER_PROTO_INHERIT = 14;

const int IFLA_BAREUDP_UNSPEC = 0;

const int IFLA_BAREUDP_PORT = 1;

const int IFLA_BAREUDP_ETHERTYPE = 2;

const int IFLA_BAREUDP_SRCPORT_MIN = 3;

const int IFLA_BAREUDP_MULTIPROTO_MODE = 4;

const int IFLA_PPP_UNSPEC = 0;

const int IFLA_PPP_DEV_FD = 1;

const int IFLA_GTP_UNSPEC = 0;

const int IFLA_GTP_FD0 = 1;

const int IFLA_GTP_FD1 = 2;

const int IFLA_GTP_PDP_HASHSIZE = 3;

const int IFLA_GTP_ROLE = 4;

const int IFLA_GTP_CREATE_SOCKETS = 5;

const int IFLA_GTP_RESTART_COUNT = 6;

const int IFLA_BOND_UNSPEC = 0;

const int IFLA_BOND_MODE = 1;

const int IFLA_BOND_ACTIVE_SLAVE = 2;

const int IFLA_BOND_MIIMON = 3;

const int IFLA_BOND_UPDELAY = 4;

const int IFLA_BOND_DOWNDELAY = 5;

const int IFLA_BOND_USE_CARRIER = 6;

const int IFLA_BOND_ARP_INTERVAL = 7;

const int IFLA_BOND_ARP_IP_TARGET = 8;

const int IFLA_BOND_ARP_VALIDATE = 9;

const int IFLA_BOND_ARP_ALL_TARGETS = 10;

const int IFLA_BOND_PRIMARY = 11;

const int IFLA_BOND_PRIMARY_RESELECT = 12;

const int IFLA_BOND_FAIL_OVER_MAC = 13;

const int IFLA_BOND_XMIT_HASH_POLICY = 14;

const int IFLA_BOND_RESEND_IGMP = 15;

const int IFLA_BOND_NUM_PEER_NOTIF = 16;

const int IFLA_BOND_ALL_SLAVES_ACTIVE = 17;

const int IFLA_BOND_MIN_LINKS = 18;

const int IFLA_BOND_LP_INTERVAL = 19;

const int IFLA_BOND_PACKETS_PER_SLAVE = 20;

const int IFLA_BOND_AD_LACP_RATE = 21;

const int IFLA_BOND_AD_SELECT = 22;

const int IFLA_BOND_AD_INFO = 23;

const int IFLA_BOND_AD_ACTOR_SYS_PRIO = 24;

const int IFLA_BOND_AD_USER_PORT_KEY = 25;

const int IFLA_BOND_AD_ACTOR_SYSTEM = 26;

const int IFLA_BOND_TLB_DYNAMIC_LB = 27;

const int IFLA_BOND_PEER_NOTIF_DELAY = 28;

const int IFLA_BOND_AD_LACP_ACTIVE = 29;

const int IFLA_BOND_MISSED_MAX = 30;

const int IFLA_BOND_NS_IP6_TARGET = 31;

const int IFLA_BOND_AD_INFO_UNSPEC = 0;

const int IFLA_BOND_AD_INFO_AGGREGATOR = 1;

const int IFLA_BOND_AD_INFO_NUM_PORTS = 2;

const int IFLA_BOND_AD_INFO_ACTOR_KEY = 3;

const int IFLA_BOND_AD_INFO_PARTNER_KEY = 4;

const int IFLA_BOND_AD_INFO_PARTNER_MAC = 5;

const int IFLA_BOND_SLAVE_UNSPEC = 0;

const int IFLA_BOND_SLAVE_STATE = 1;

const int IFLA_BOND_SLAVE_MII_STATUS = 2;

const int IFLA_BOND_SLAVE_LINK_FAILURE_COUNT = 3;

const int IFLA_BOND_SLAVE_PERM_HWADDR = 4;

const int IFLA_BOND_SLAVE_QUEUE_ID = 5;

const int IFLA_BOND_SLAVE_AD_AGGREGATOR_ID = 6;

const int IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE = 7;

const int IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE = 8;

const int IFLA_BOND_SLAVE_PRIO = 9;

const int IFLA_VF_INFO_UNSPEC = 0;

const int IFLA_VF_INFO = 1;

const int IFLA_VF_UNSPEC = 0;

const int IFLA_VF_MAC = 1;

const int IFLA_VF_VLAN = 2;

const int IFLA_VF_TX_RATE = 3;

const int IFLA_VF_SPOOFCHK = 4;

const int IFLA_VF_LINK_STATE = 5;

const int IFLA_VF_RATE = 6;

const int IFLA_VF_RSS_QUERY_EN = 7;

const int IFLA_VF_STATS = 8;

const int IFLA_VF_TRUST = 9;

const int IFLA_VF_IB_NODE_GUID = 10;

const int IFLA_VF_IB_PORT_GUID = 11;

const int IFLA_VF_VLAN_LIST = 12;

const int IFLA_VF_BROADCAST = 13;

const int IFLA_VF_VLAN_INFO_UNSPEC = 0;

const int IFLA_VF_VLAN_INFO = 1;

const int IFLA_VF_LINK_STATE_AUTO = 0;

const int IFLA_VF_LINK_STATE_ENABLE = 1;

const int IFLA_VF_LINK_STATE_DISABLE = 2;

const int IFLA_VF_STATS_RX_PACKETS = 0;

const int IFLA_VF_STATS_TX_PACKETS = 1;

const int IFLA_VF_STATS_RX_BYTES = 2;

const int IFLA_VF_STATS_TX_BYTES = 3;

const int IFLA_VF_STATS_BROADCAST = 4;

const int IFLA_VF_STATS_MULTICAST = 5;

const int IFLA_VF_STATS_PAD = 6;

const int IFLA_VF_STATS_RX_DROPPED = 7;

const int IFLA_VF_STATS_TX_DROPPED = 8;

const int IFLA_VF_PORT_UNSPEC = 0;

const int IFLA_VF_PORT = 1;

const int IFLA_PORT_UNSPEC = 0;

const int IFLA_PORT_VF = 1;

const int IFLA_PORT_PROFILE = 2;

const int IFLA_PORT_VSI_TYPE = 3;

const int IFLA_PORT_INSTANCE_UUID = 4;

const int IFLA_PORT_HOST_UUID = 5;

const int IFLA_PORT_REQUEST = 6;

const int IFLA_PORT_RESPONSE = 7;

const int IFLA_IPOIB_UNSPEC = 0;

const int IFLA_IPOIB_PKEY = 1;

const int IFLA_IPOIB_MODE = 2;

const int IFLA_IPOIB_UMCAST = 3;

const int IFLA_HSR_UNSPEC = 0;

const int IFLA_HSR_SLAVE1 = 1;

const int IFLA_HSR_SLAVE2 = 2;

const int IFLA_HSR_MULTICAST_SPEC = 3;

const int IFLA_HSR_SUPERVISION_ADDR = 4;

const int IFLA_HSR_SEQ_NR = 5;

const int IFLA_HSR_VERSION = 6;

const int IFLA_HSR_PROTOCOL = 7;

const int IFLA_STATS_UNSPEC = 0;

const int IFLA_STATS_LINK_64 = 1;

const int IFLA_STATS_LINK_XSTATS = 2;

const int IFLA_STATS_LINK_XSTATS_SLAVE = 3;

const int IFLA_STATS_LINK_OFFLOAD_XSTATS = 4;

const int IFLA_STATS_AF_SPEC = 5;

const int IFLA_STATS_GETSET_UNSPEC = 0;

const int IFLA_STATS_GET_FILTERS = 1;

const int IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS = 2;

const int IFLA_OFFLOAD_XSTATS_UNSPEC = 0;

const int IFLA_OFFLOAD_XSTATS_CPU_HIT = 1;

const int IFLA_OFFLOAD_XSTATS_HW_S_INFO = 2;

const int IFLA_OFFLOAD_XSTATS_L3_STATS = 3;

const int IFLA_OFFLOAD_XSTATS_HW_S_INFO_UNSPEC = 0;

const int IFLA_OFFLOAD_XSTATS_HW_S_INFO_REQUEST = 1;

const int IFLA_OFFLOAD_XSTATS_HW_S_INFO_USED = 2;

const int IFLA_XDP_UNSPEC = 0;

const int IFLA_XDP_FD = 1;

const int IFLA_XDP_ATTACHED = 2;

const int IFLA_XDP_FLAGS = 3;

const int IFLA_XDP_PROG_ID = 4;

const int IFLA_XDP_DRV_PROG_ID = 5;

const int IFLA_XDP_SKB_PROG_ID = 6;

const int IFLA_XDP_HW_PROG_ID = 7;

const int IFLA_XDP_EXPECTED_FD = 8;

const int IFLA_EVENT_NONE = 0;

const int IFLA_EVENT_REBOOT = 1;

const int IFLA_EVENT_FEATURES = 2;

const int IFLA_EVENT_BONDING_FAILOVER = 3;

const int IFLA_EVENT_NOTIFY_PEERS = 4;

const int IFLA_EVENT_IGMP_RESEND = 5;

const int IFLA_EVENT_BONDING_OPTIONS = 6;

const int IFLA_TUN_UNSPEC = 0;

const int IFLA_TUN_OWNER = 1;

const int IFLA_TUN_GROUP = 2;

const int IFLA_TUN_TYPE = 3;

const int IFLA_TUN_PI = 4;

const int IFLA_TUN_VNET_HDR = 5;

const int IFLA_TUN_PERSIST = 6;

const int IFLA_TUN_MULTI_QUEUE = 7;

const int IFLA_TUN_NUM_QUEUES = 8;

const int IFLA_TUN_NUM_DISABLED_QUEUES = 9;

const int IFLA_RMNET_UNSPEC = 0;

const int IFLA_RMNET_MUX_ID = 1;

const int IFLA_RMNET_FLAGS = 2;

const int IFLA_MCTP_UNSPEC = 0;

const int IFLA_MCTP_NET = 1;

const int IFLA_DSA_UNSPEC = 0;

const int IFLA_DSA_MASTER = 1;

const int IFLA_CAN_UNSPEC = 0;

const int IFLA_CAN_BITTIMING = 1;

const int IFLA_CAN_BITTIMING_CONST = 2;

const int IFLA_CAN_CLOCK = 3;

const int IFLA_CAN_STATE = 4;

const int IFLA_CAN_CTRLMODE = 5;

const int IFLA_CAN_RESTART_MS = 6;

const int IFLA_CAN_RESTART = 7;

const int IFLA_CAN_BERR_COUNTER = 8;

const int IFLA_CAN_DATA_BITTIMING = 9;

const int IFLA_CAN_DATA_BITTIMING_CONST = 10;

const int IFLA_CAN_TERMINATION = 11;

const int IFLA_CAN_TERMINATION_CONST = 12;

const int IFLA_CAN_BITRATE_CONST = 13;

const int IFLA_CAN_DATA_BITRATE_CONST = 14;

const int IFLA_CAN_BITRATE_MAX = 15;

const int IFLA_CAN_TDC = 16;

const int IFLA_CAN_CTRLMODE_EXT = 17;

const int IFLA_CAN_MAX = 17;

const int IFLA_CAN_TDC_UNSPEC = 0;

const int IFLA_CAN_TDC_TDCV_MIN = 1;

const int IFLA_CAN_TDC_TDCV_MAX = 2;

const int IFLA_CAN_TDC_TDCO_MIN = 3;

const int IFLA_CAN_TDC_TDCO_MAX = 4;

const int IFLA_CAN_TDC_TDCF_MIN = 5;

const int IFLA_CAN_TDC_TDCF_MAX = 6;

const int IFLA_CAN_TDC_TDCV = 7;

const int IFLA_CAN_TDC_TDCO = 8;

const int IFLA_CAN_TDC_TDCF = 9;

const int IFLA_CAN_TDC_MAX = 9;

const int IFLA_CAN_CTRLMODE_UNSPEC = 0;

const int IFLA_CAN_CTRLMODE_SUPPORTED = 1;

const int IFLA_CAN_CTRLMODE_MAX = 1;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EAGAIN = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int ENOTBLK = 15;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int EINVAL = 22;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int ETXTBSY = 26;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int ERANGE = 34;

const int EDEADLK = 35;

const int ENAMETOOLONG = 36;

const int ENOLCK = 37;

const int ENOSYS = 38;

const int ENOTEMPTY = 39;

const int ELOOP = 40;

const int EWOULDBLOCK = 11;

const int ENOMSG = 42;

const int EIDRM = 43;

const int ECHRNG = 44;

const int EL2NSYNC = 45;

const int EL3HLT = 46;

const int EL3RST = 47;

const int ELNRNG = 48;

const int EUNATCH = 49;

const int ENOCSI = 50;

const int EL2HLT = 51;

const int EBADE = 52;

const int EBADR = 53;

const int EXFULL = 54;

const int ENOANO = 55;

const int EBADRQC = 56;

const int EBADSLT = 57;

const int EDEADLOCK = 35;

const int EBFONT = 59;

const int ENOSTR = 60;

const int ENODATA = 61;

const int ETIME = 62;

const int ENOSR = 63;

const int ENONET = 64;

const int ENOPKG = 65;

const int EREMOTE = 66;

const int ENOLINK = 67;

const int EADV = 68;

const int ESRMNT = 69;

const int ECOMM = 70;

const int EPROTO = 71;

const int EMULTIHOP = 72;

const int EDOTDOT = 73;

const int EBADMSG = 74;

const int EOVERFLOW = 75;

const int ENOTUNIQ = 76;

const int EBADFD = 77;

const int EREMCHG = 78;

const int ELIBACC = 79;

const int ELIBBAD = 80;

const int ELIBSCN = 81;

const int ELIBMAX = 82;

const int ELIBEXEC = 83;

const int EILSEQ = 84;

const int ERESTART = 85;

const int ESTRPIPE = 86;

const int EUSERS = 87;

const int ENOTSOCK = 88;

const int EDESTADDRREQ = 89;

const int EMSGSIZE = 90;

const int EPROTOTYPE = 91;

const int ENOPROTOOPT = 92;

const int EPROTONOSUPPORT = 93;

const int ESOCKTNOSUPPORT = 94;

const int EOPNOTSUPP = 95;

const int EPFNOSUPPORT = 96;

const int EAFNOSUPPORT = 97;

const int EADDRINUSE = 98;

const int EADDRNOTAVAIL = 99;

const int ENETDOWN = 100;

const int ENETUNREACH = 101;

const int ENETRESET = 102;

const int ECONNABORTED = 103;

const int ECONNRESET = 104;

const int ENOBUFS = 105;

const int EISCONN = 106;

const int ENOTCONN = 107;

const int ESHUTDOWN = 108;

const int ETOOMANYREFS = 109;

const int ETIMEDOUT = 110;

const int ECONNREFUSED = 111;

const int EHOSTDOWN = 112;

const int EHOSTUNREACH = 113;

const int EALREADY = 114;

const int EINPROGRESS = 115;

const int ESTALE = 116;

const int EUCLEAN = 117;

const int ENOTNAM = 118;

const int ENAVAIL = 119;

const int EISNAM = 120;

const int EREMOTEIO = 121;

const int EDQUOT = 122;

const int ENOMEDIUM = 123;

const int EMEDIUMTYPE = 124;

const int ECANCELED = 125;

const int ENOKEY = 126;

const int EKEYEXPIRED = 127;

const int EKEYREVOKED = 128;

const int EKEYREJECTED = 129;

const int EOWNERDEAD = 130;

const int ENOTRECOVERABLE = 131;

const int ERFKILL = 132;

const int EHWPOISON = 133;

const int ENOTSUP = 95;

const int O_ACCMODE = 3;

const int O_RDONLY = 0;

const int O_WRONLY = 1;

const int O_RDWR = 2;

const int O_CREAT = 64;

const int O_EXCL = 128;

const int O_NOCTTY = 256;

const int O_TRUNC = 512;

const int O_APPEND = 1024;

const int O_NONBLOCK = 2048;

const int O_NDELAY = 2048;

const int O_SYNC = 1052672;

const int O_FSYNC = 1052672;

const int O_ASYNC = 8192;

const int O_CLOEXEC = 524288;

const int O_DSYNC = 4096;

const int O_RSYNC = 1052672;

const int SIOCADDRT = 35083;

const int SIOCDELRT = 35084;

const int SIOCRTMSG = 35085;

const int SIOCGIFNAME = 35088;

const int SIOCSIFLINK = 35089;

const int SIOCGIFCONF = 35090;

const int SIOCGIFFLAGS = 35091;

const int SIOCSIFFLAGS = 35092;

const int SIOCGIFADDR = 35093;

const int SIOCSIFADDR = 35094;

const int SIOCGIFDSTADDR = 35095;

const int SIOCSIFDSTADDR = 35096;

const int SIOCGIFBRDADDR = 35097;

const int SIOCSIFBRDADDR = 35098;

const int SIOCGIFNETMASK = 35099;

const int SIOCSIFNETMASK = 35100;

const int SIOCGIFMETRIC = 35101;

const int SIOCSIFMETRIC = 35102;

const int SIOCGIFMEM = 35103;

const int SIOCSIFMEM = 35104;

const int SIOCGIFMTU = 35105;

const int SIOCSIFMTU = 35106;

const int SIOCSIFNAME = 35107;

const int SIOCSIFHWADDR = 35108;

const int SIOCGIFENCAP = 35109;

const int SIOCSIFENCAP = 35110;

const int SIOCGIFHWADDR = 35111;

const int SIOCGIFSLAVE = 35113;

const int SIOCSIFSLAVE = 35120;

const int SIOCADDMULTI = 35121;

const int SIOCDELMULTI = 35122;

const int SIOCGIFINDEX = 35123;

const int SIOCSIFPFLAGS = 35124;

const int SIOCGIFPFLAGS = 35125;

const int SIOCDIFADDR = 35126;

const int SIOCSIFHWBROADCAST = 35127;

const int SIOCGIFCOUNT = 35128;

const int SIOCGIFBR = 35136;

const int SIOCSIFBR = 35137;

const int SIOCGIFTXQLEN = 35138;

const int SIOCSIFTXQLEN = 35139;

const int SIOCDARP = 35155;

const int SIOCGARP = 35156;

const int SIOCSARP = 35157;

const int SIOCDRARP = 35168;

const int SIOCGRARP = 35169;

const int SIOCSRARP = 35170;

const int SIOCGIFMAP = 35184;

const int SIOCSIFMAP = 35185;

const int SIOCADDDLCI = 35200;

const int SIOCDELDLCI = 35201;

const int SIOCDEVPRIVATE = 35312;

const int SIOCPROTOPRIVATE = 35296;

const int EPOLL_CLOEXEC1 = 524288;

const int EPOLLIN = 1;

const int EPOLLPRI = 2;

const int EPOLLOUT = 4;

const int EPOLLRDNORM = 64;

const int EPOLLRDBAND = 128;

const int EPOLLWRNORM = 256;

const int EPOLLWRBAND = 512;

const int EPOLLMSG = 1024;

const int EPOLLERR = 8;

const int EPOLLHUP = 16;

const int EPOLLRDHUP = 8192;

const int EPOLLEXCLUSIVE = 268435456;

const int EPOLLWAKEUP = 536870912;

const int EPOLLONESHOT = 1073741824;

const int EPOLLET = 2147483648;

const int EPOLL_CTL_ADD = 1;

const int EPOLL_CTL_DEL = 2;

const int EPOLL_CTL_MOD = 3;

const int EFD_SEMAPHORE = 1;

const int EFD_CLOEXEC = 524288;

const int EFD_NONBLOCK = 2048;

const int GPIO_MAX_NAME_SIZE = 32;

const int GPIO_V2_LINES_MAX = 64;

const int GPIO_V2_LINE_NUM_ATTRS_MAX = 10;

const int GPIOLINE_FLAG_KERNEL = 1;

const int GPIOLINE_FLAG_IS_OUT = 2;

const int GPIOLINE_FLAG_ACTIVE_LOW = 4;

const int GPIOLINE_FLAG_OPEN_DRAIN = 8;

const int GPIOLINE_FLAG_OPEN_SOURCE = 16;

const int GPIOLINE_FLAG_BIAS_PULL_UP = 32;

const int GPIOLINE_FLAG_BIAS_PULL_DOWN = 64;

const int GPIOLINE_FLAG_BIAS_DISABLE = 128;

const int GPIOHANDLES_MAX = 64;

const int GPIOHANDLE_REQUEST_INPUT = 1;

const int GPIOHANDLE_REQUEST_OUTPUT = 2;

const int GPIOHANDLE_REQUEST_ACTIVE_LOW = 4;

const int GPIOHANDLE_REQUEST_OPEN_DRAIN = 8;

const int GPIOHANDLE_REQUEST_OPEN_SOURCE = 16;

const int GPIOHANDLE_REQUEST_BIAS_PULL_UP = 32;

const int GPIOHANDLE_REQUEST_BIAS_PULL_DOWN = 64;

const int GPIOHANDLE_REQUEST_BIAS_DISABLE = 128;

const int GPIOEVENT_REQUEST_RISING_EDGE = 1;

const int GPIOEVENT_REQUEST_FALLING_EDGE = 2;

const int GPIOEVENT_REQUEST_BOTH_EDGES = 3;

const int GPIOEVENT_EVENT_RISING_EDGE = 1;

const int GPIOEVENT_EVENT_FALLING_EDGE = 2;

const int GPIO_GET_CHIPINFO_IOCTL = 2151986177;

const int GPIO_GET_LINEINFO_UNWATCH_IOCTL = 3221533708;

const int GPIO_V2_GET_LINEINFO_IOCTL = 3238048773;

const int GPIO_V2_GET_LINEINFO_WATCH_IOCTL = 3238048774;

const int GPIO_V2_GET_LINE_IOCTL = 3260068871;

const int GPIO_V2_LINE_SET_CONFIG_IOCTL = 3239097357;

const int GPIO_V2_LINE_GET_VALUES_IOCTL = 3222320142;

const int GPIO_V2_LINE_SET_VALUES_IOCTL = 3222320143;

const int GPIO_GET_LINEINFO_IOCTL = 3225990146;

const int GPIO_GET_LINEHANDLE_IOCTL = 3245126659;

const int GPIO_GET_LINEEVENT_IOCTL = 3224417284;

const int GPIOHANDLE_GET_LINE_VALUES_IOCTL = 3225465864;

const int GPIOHANDLE_SET_LINE_VALUES_IOCTL = 3225465865;

const int GPIOHANDLE_SET_CONFIG_IOCTL = 3226776586;

const int GPIO_GET_LINEINFO_WATCH_IOCTL = 3225990155;

const int NCCS = 32;

const int VINTR = 0;

const int VQUIT = 1;

const int VKILL = 3;

const int VEOF = 4;

const int VTIME = 5;

const int VMIN = 6;

const int VSTART = 8;

const int VSTOP = 9;

const int VSUSP = 10;

const int VEOL = 11;

const int IGNBRK = 1;

const int BRKINT = 2;

const int IGNPAR = 4;

const int PARMRK = 8;

const int INPCK = 16;

const int ISTRIP = 32;

const int INLCR = 64;

const int IGNCR = 128;

const int ICRNL = 256;

const int IXON = 1024;

const int IXANY = 2048;

const int IXOFF = 4096;

const int OPOST = 1;

const int ONLCR = 4;

const int OCRNL = 8;

const int ONOCR = 16;

const int ONLRET = 32;

const int OFILL = 64;

const int OFDEL = 128;

const int NLDLY = 256;

const int NL0 = 0;

const int NL1 = 256;

const int CRDLY = 1536;

const int CR0 = 0;

const int CR1 = 512;

const int CR2 = 1024;

const int CR3 = 1536;

const int TABDLY = 6144;

const int TAB0 = 0;

const int TAB1 = 2048;

const int TAB2 = 4096;

const int TAB3 = 6144;

const int BSDLY = 8192;

const int BS0 = 0;

const int BS1 = 8192;

const int FFDLY = 32768;

const int FF0 = 0;

const int FF1 = 32768;

const int VTDLY = 16384;

const int VT0 = 0;

const int VT1 = 16384;

const int B0 = 0;

const int B50 = 1;

const int B75 = 2;

const int B110 = 3;

const int B134 = 4;

const int B150 = 5;

const int B200 = 6;

const int B300 = 7;

const int B600 = 8;

const int B1200 = 9;

const int B1800 = 10;

const int B2400 = 11;

const int B4800 = 12;

const int B9600 = 13;

const int B19200 = 14;

const int B38400 = 15;

const int EXTA = 14;

const int EXTB = 15;

const int B57600 = 4097;

const int B115200 = 4098;

const int B230400 = 4099;

const int B460800 = 4100;

const int B500000 = 4101;

const int B576000 = 4102;

const int B921600 = 4103;

const int B1000000 = 4104;

const int B1152000 = 4105;

const int B1500000 = 4106;

const int B2000000 = 4107;

const int B2500000 = 4108;

const int B3000000 = 4109;

const int B3500000 = 4110;

const int B4000000 = 4111;

const int CSIZE = 48;

const int CS5 = 0;

const int CS6 = 16;

const int CS7 = 32;

const int CS8 = 48;

const int CSTOPB = 64;

const int CREAD = 128;

const int PARENB = 256;

const int PARODD = 512;

const int HUPCL = 1024;

const int CLOCAL = 2048;

const int ISIG = 1;

const int ICANON = 2;

const int ECHO = 8;

const int ECHOE = 16;

const int ECHOK = 32;

const int ECHONL = 64;

const int NOFLSH = 128;

const int TOSTOP = 256;

const int ECHOCTL = 512;

const int ECHOPRT = 1024;

const int ECHOKE = 2048;

const int IEXTEN = 32768;

const int EXTPROC = 65536;

const int TCOOFF = 0;

const int TCOON = 1;

const int TCIOFF = 2;

const int TCION = 3;

const int TCIFLUSH = 0;

const int TCOFLUSH = 1;

const int TCIOFLUSH = 2;

const int TCSANOW = 0;

const int TCSADRAIN = 1;

const int TCSAFLUSH = 2;

const int SPI_CPHA = 1;

const int SPI_CPOL = 2;

const int SPI_MODE_0 = 0;

const int SPI_MODE_1 = 1;

const int SPI_MODE_2 = 2;

const int SPI_MODE_3 = 3;

const int SPI_MODE_X_MASK = 3;

const int SPI_CS_HIGH = 4;

const int SPI_LSB_FIRST = 8;

const int SPI_3WIRE = 16;

const int SPI_LOOP = 32;

const int SPI_NO_CS = 64;

const int SPI_READY = 128;

const int SPI_TX_DUAL = 256;

const int SPI_TX_QUAD = 512;

const int SPI_RX_DUAL = 1024;

const int SPI_RX_QUAD = 2048;

const int SPI_CS_WORD = 4096;

const int SPI_TX_OCTAL = 8192;

const int SPI_RX_OCTAL = 16384;

const int SPI_3WIRE_HIZ = 32768;

const int SPI_IOC_MAGIC = 107;

const int SPI_IOC_RD_MODE = 2147576577;

const int SPI_IOC_WR_MODE = 1073834753;

const int SPI_IOC_RD_LSB_FIRST = 2147576578;

const int SPI_IOC_WR_LSB_FIRST = 1073834754;

const int SPI_IOC_RD_BITS_PER_WORD = 2147576579;

const int SPI_IOC_WR_BITS_PER_WORD = 1073834755;

const int SPI_IOC_RD_MAX_SPEED_HZ = 2147773188;

const int SPI_IOC_WR_MAX_SPEED_HZ = 1074031364;

const int SPI_IOC_RD_MODE32 = 2147773189;

const int SPI_IOC_WR_MODE32 = 1074031365;

const int SOCK_STREAM = 1;

const int SOCK_DGRAM = 2;

const int SOCK_RAW = 3;

const int SOCK_RDM = 4;

const int SOCK_SEQPACKET = 5;

const int SOCK_DCCP = 6;

const int SOCK_PACKET = 10;

const int SOCK_CLOEXEC = 524288;

const int SOCK_NONBLOCK = 2048;

const int PF_CAN = 29;

const int AF_NETLINK = 16;

const int AF_CAN = 29;

const int SOL_RAW = 255;

const int SOL_DECNET = 261;

const int SOL_X25 = 262;

const int SOL_PACKET = 263;

const int SOL_ATM = 264;

const int SOL_AAL = 265;

const int SOL_IRDA = 266;

const int SOL_NETBEUI = 267;

const int SOL_LLC = 268;

const int SOL_DCCP = 269;

const int SOL_NETLINK = 270;

const int SOL_TIPC = 271;

const int SOL_RXRPC = 272;

const int SOL_PPPOL2TP = 273;

const int SOL_BLUETOOTH = 274;

const int SOL_PNPIPE = 275;

const int SOL_RDS = 276;

const int SOL_IUCV = 277;

const int SOL_CAIF = 278;

const int SOL_ALG = 279;

const int SOL_NFC = 280;

const int SOL_KCM = 281;

const int SOL_TLS = 282;

const int SOL_XDP = 283;

const int SOL_MPTCP = 284;

const int SOL_MCTP = 285;

const int SOL_SMC = 286;

const int MSG_OOB = 1;

const int MSG_PEEK = 2;

const int MSG_DONTROUTE = 4;

const int MSG_CTRUNC = 8;

const int MSG_PROXY = 16;

const int MSG_TRUNC = 32;

const int MSG_DONTWAIT = 64;

const int MSG_EOR = 128;

const int MSG_WAITALL = 256;

const int MSG_FIN = 512;

const int MSG_SYN = 1024;

const int MSG_CONFIRM = 2048;

const int MSG_RST = 4096;

const int MSG_ERRQUEUE = 8192;

const int MSG_NOSIGNAL = 16384;

const int MSG_MORE = 32768;

const int MSG_WAITFORONE = 65536;

const int MSG_BATCH = 262144;

const int MSG_ZEROCOPY = 67108864;

const int MSG_FASTOPEN = 536870912;

const int MSG_CMSG_CLOEXEC = 1073741824;

const int SIOCSPGRP = 35074;

const int SIOCGPGRP = 35076;

const int SIOCATMARK = 35077;

const int SIOCGSTAMP_OLD = 35078;

const int SIOCGSTAMPNS_OLD = 35079;

const int SOL_SOCKET = 1;

const int SO_DEBUG = 1;

const int SO_REUSEADDR = 2;

const int SO_TYPE = 3;

const int SO_ERROR = 4;

const int SO_DONTROUTE = 5;

const int SO_BROADCAST = 6;

const int SO_SNDBUF = 7;

const int SO_RCVBUF = 8;

const int SO_SNDBUFFORCE = 32;

const int SO_RCVBUFFORCE = 33;

const int SO_KEEPALIVE = 9;

const int SO_OOBINLINE = 10;

const int SO_NO_CHECK = 11;

const int SO_PRIORITY = 12;

const int SO_LINGER = 13;

const int SO_BSDCOMPAT = 14;

const int SO_REUSEPORT = 15;

const int SO_PASSCRED = 16;

const int SO_PEERCRED = 17;

const int SO_RCVLOWAT = 18;

const int SO_SNDLOWAT = 19;

const int SO_RCVTIMEO_OLD = 20;

const int SO_SNDTIMEO_OLD = 21;

const int SO_SECURITY_AUTHENTICATION = 22;

const int SO_SECURITY_ENCRYPTION_TRANSPORT = 23;

const int SO_SECURITY_ENCRYPTION_NETWORK = 24;

const int SO_BINDTODEVICE = 25;

const int SO_ATTACH_FILTER = 26;

const int SO_DETACH_FILTER = 27;

const int SO_GET_FILTER = 26;

const int SO_PEERNAME = 28;

const int SO_ACCEPTCONN = 30;

const int SO_PEERSEC = 31;

const int SO_PASSSEC = 34;

const int SO_MARK = 36;

const int SO_PROTOCOL = 38;

const int SO_DOMAIN = 39;

const int SO_RXQ_OVFL = 40;

const int SO_WIFI_STATUS = 41;

const int SO_PEEK_OFF = 42;

const int SO_NOFCS = 43;

const int SO_LOCK_FILTER = 44;

const int SO_SELECT_ERR_QUEUE = 45;

const int SO_BUSY_POLL = 46;

const int SO_MAX_PACING_RATE = 47;

const int SO_BPF_EXTENSIONS = 48;

const int SO_INCOMING_CPU = 49;

const int SO_ATTACH_BPF = 50;

const int SO_DETACH_BPF = 27;

const int SO_ATTACH_REUSEPORT_CBPF = 51;

const int SO_ATTACH_REUSEPORT_EBPF = 52;

const int SO_CNX_ADVICE = 53;

const int SO_MEMINFO = 55;

const int SO_INCOMING_NAPI_ID = 56;

const int SO_COOKIE = 57;

const int SO_PEERGROUPS = 59;

const int SO_ZEROCOPY = 60;

const int SO_TXTIME = 61;

const int SO_BINDTOIFINDEX = 62;

const int SO_TIMESTAMP_OLD = 29;

const int SO_TIMESTAMPNS_OLD = 35;

const int SO_TIMESTAMPING_OLD = 37;

const int SO_TIMESTAMP_NEW = 63;

const int SO_TIMESTAMPNS_NEW = 64;

const int SO_TIMESTAMPING_NEW = 65;

const int SO_RCVTIMEO_NEW = 66;

const int SO_SNDTIMEO_NEW = 67;

const int SO_DETACH_REUSEPORT_BPF = 68;

const int SO_PREFER_BUSY_POLL = 69;

const int SO_BUSY_POLL_BUDGET = 70;

const int SO_NETNS_COOKIE = 71;

const int SO_BUF_LOCK = 72;

const int SO_RESERVE_MEM = 73;

const int SO_TXREHASH = 74;

const int SO_RCVMARK = 75;

const int SO_TIMESTAMP = 29;

const int SO_TIMESTAMPNS = 35;

const int SO_TIMESTAMPING = 37;

const int SO_RCVTIMEO = 20;

const int SO_SNDTIMEO = 21;

const int IF_NAMESIZE = 16;

const int IFF_UP = 1;

const int IFF_BROADCAST = 2;

const int IFF_DEBUG = 4;

const int IFF_LOOPBACK = 8;

const int IFF_POINTOPOINT = 16;

const int IFF_NOTRAILERS = 32;

const int IFF_RUNNING = 64;

const int IFF_NOARP = 128;

const int IFF_PROMISC = 256;

const int IFF_ALLMULTI = 512;

const int IFF_MASTER = 1024;

const int IFF_SLAVE = 2048;

const int IFF_MULTICAST = 4096;

const int IFF_PORTSEL = 8192;

const int IFF_AUTOMEDIA = 16384;

const int IFF_DYNAMIC = 32768;

const int IFNAMSIZ = 16;

const int SOCK_SNDBUF_LOCK = 1;

const int SOCK_RCVBUF_LOCK = 2;

const int SOCK_BUF_LOCK_MASK = 3;

const int SOCK_TXREHASH_DEFAULT = 255;

const int SOCK_TXREHASH_DISABLED = 0;

const int SOCK_TXREHASH_ENABLED = 1;

const int CAN_EFF_FLAG = 2147483648;

const int CAN_RTR_FLAG = 1073741824;

const int CAN_ERR_FLAG = 536870912;

const int CAN_SFF_MASK = 2047;

const int CAN_EFF_MASK = 536870911;

const int CAN_ERR_MASK = 536870911;

const int CAN_SFF_ID_BITS = 11;

const int CAN_EFF_ID_BITS = 29;

const int CAN_MAX_DLC = 8;

const int CAN_MAX_RAW_DLC = 15;

const int CAN_MAX_DLEN = 8;

const int CANFD_MAX_DLC = 15;

const int CANFD_MAX_DLEN = 64;

const int CANFD_BRS = 1;

const int CANFD_ESI = 2;

const int CANFD_FDF = 4;

const int CAN_MTU = 16;

const int CANFD_MTU = 72;

const int CAN_RAW = 1;

const int CAN_BCM = 2;

const int CAN_TP16 = 3;

const int CAN_TP20 = 4;

const int CAN_MCNET = 5;

const int CAN_ISOTP = 6;

const int CAN_J1939 = 7;

const int CAN_NPROTO = 8;

const int SOL_CAN_BASE = 100;

const int CAN_INV_FILTER = 536870912;

const int CAN_RAW_FILTER_MAX = 512;

const int SOL_CAN_RAW = 101;

const int CAN_ERR_DLC = 8;

const int CAN_ERR_TX_TIMEOUT = 1;

const int CAN_ERR_LOSTARB = 2;

const int CAN_ERR_CRTL = 4;

const int CAN_ERR_PROT = 8;

const int CAN_ERR_TRX = 16;

const int CAN_ERR_ACK = 32;

const int CAN_ERR_BUSOFF = 64;

const int CAN_ERR_BUSERROR = 128;

const int CAN_ERR_RESTARTED = 256;

const int CAN_ERR_CNT = 512;

const int CAN_ERR_LOSTARB_UNSPEC = 0;

const int CAN_ERR_CRTL_UNSPEC = 0;

const int CAN_ERR_CRTL_RX_OVERFLOW = 1;

const int CAN_ERR_CRTL_TX_OVERFLOW = 2;

const int CAN_ERR_CRTL_RX_WARNING = 4;

const int CAN_ERR_CRTL_TX_WARNING = 8;

const int CAN_ERR_CRTL_RX_PASSIVE = 16;

const int CAN_ERR_CRTL_TX_PASSIVE = 32;

const int CAN_ERR_CRTL_ACTIVE = 64;

const int CAN_ERR_PROT_UNSPEC = 0;

const int CAN_ERR_PROT_BIT = 1;

const int CAN_ERR_PROT_FORM = 2;

const int CAN_ERR_PROT_STUFF = 4;

const int CAN_ERR_PROT_BIT0 = 8;

const int CAN_ERR_PROT_BIT1 = 16;

const int CAN_ERR_PROT_OVERLOAD = 32;

const int CAN_ERR_PROT_ACTIVE = 64;

const int CAN_ERR_PROT_TX = 128;

const int CAN_ERR_PROT_LOC_UNSPEC = 0;

const int CAN_ERR_PROT_LOC_SOF = 3;

const int CAN_ERR_PROT_LOC_ID28_21 = 2;

const int CAN_ERR_PROT_LOC_ID20_18 = 6;

const int CAN_ERR_PROT_LOC_SRTR = 4;

const int CAN_ERR_PROT_LOC_IDE = 5;

const int CAN_ERR_PROT_LOC_ID17_13 = 7;

const int CAN_ERR_PROT_LOC_ID12_05 = 15;

const int CAN_ERR_PROT_LOC_ID04_00 = 14;

const int CAN_ERR_PROT_LOC_RTR = 12;

const int CAN_ERR_PROT_LOC_RES1 = 13;

const int CAN_ERR_PROT_LOC_RES0 = 9;

const int CAN_ERR_PROT_LOC_DLC = 11;

const int CAN_ERR_PROT_LOC_DATA = 10;

const int CAN_ERR_PROT_LOC_CRC_SEQ = 8;

const int CAN_ERR_PROT_LOC_CRC_DEL = 24;

const int CAN_ERR_PROT_LOC_ACK = 25;

const int CAN_ERR_PROT_LOC_ACK_DEL = 27;

const int CAN_ERR_PROT_LOC_EOF = 26;

const int CAN_ERR_PROT_LOC_INTERM = 18;

const int CAN_ERR_TRX_UNSPEC = 0;

const int CAN_ERR_TRX_CANH_NO_WIRE = 4;

const int CAN_ERR_TRX_CANH_SHORT_TO_BAT = 5;

const int CAN_ERR_TRX_CANH_SHORT_TO_VCC = 6;

const int CAN_ERR_TRX_CANH_SHORT_TO_GND = 7;

const int CAN_ERR_TRX_CANL_NO_WIRE = 64;

const int CAN_ERR_TRX_CANL_SHORT_TO_BAT = 80;

const int CAN_ERR_TRX_CANL_SHORT_TO_VCC = 96;

const int CAN_ERR_TRX_CANL_SHORT_TO_GND = 112;

const int CAN_ERR_TRX_CANL_SHORT_TO_CANH = 128;

const int CAN_ERROR_WARNING_THRESHOLD = 96;

const int CAN_ERROR_PASSIVE_THRESHOLD = 128;

const int CAN_BUS_OFF_THRESHOLD = 256;

const int NETLINK_ROUTE = 0;

const int NETLINK_UNUSED = 1;

const int NETLINK_USERSOCK = 2;

const int NETLINK_FIREWALL = 3;

const int NETLINK_SOCK_DIAG = 4;

const int NETLINK_NFLOG = 5;

const int NETLINK_XFRM = 6;

const int NETLINK_SELINUX = 7;

const int NETLINK_ISCSI = 8;

const int NETLINK_AUDIT = 9;

const int NETLINK_FIB_LOOKUP = 10;

const int NETLINK_CONNECTOR = 11;

const int NETLINK_NETFILTER = 12;

const int NETLINK_IP6_FW = 13;

const int NETLINK_DNRTMSG = 14;

const int NETLINK_KOBJECT_UEVENT = 15;

const int NETLINK_GENERIC = 16;

const int NETLINK_SCSITRANSPORT = 18;

const int NETLINK_ECRYPTFS = 19;

const int NETLINK_RDMA = 20;

const int NETLINK_CRYPTO = 21;

const int NETLINK_SMC = 22;

const int NETLINK_INET_DIAG = 4;

const int NLM_F_REQUEST = 1;

const int NLM_F_MULTI = 2;

const int NLM_F_ACK = 4;

const int NLM_F_ECHO = 8;

const int NLM_F_DUMP_INTR = 16;

const int NLM_F_DUMP_FILTERED = 32;

const int NLM_F_ROOT = 256;

const int NLM_F_MATCH = 512;

const int NLM_F_ATOMIC = 1024;

const int NLM_F_DUMP = 768;

const int NLM_F_REPLACE = 256;

const int NLM_F_EXCL = 512;

const int NLM_F_CREATE = 1024;

const int NLM_F_APPEND = 2048;

const int NLM_F_NONREC = 256;

const int NLM_F_BULK = 512;

const int NLM_F_CAPPED = 256;

const int NLM_F_ACK_TLVS = 512;

const int NLMSG_ALIGNTO = 4;

const int NLMSG_HDRLEN = 16;

const int NLMSG_NOOP = 1;

const int NLMSG_ERROR = 2;

const int NLMSG_DONE = 3;

const int NLMSG_OVERRUN = 4;

const int NLMSG_MIN_TYPE = 16;

const int NETLINK_ADD_MEMBERSHIP = 1;

const int NETLINK_DROP_MEMBERSHIP = 2;

const int NETLINK_PKTINFO = 3;

const int NETLINK_BROADCAST_ERROR = 4;

const int NETLINK_NO_ENOBUFS = 5;

const int NETLINK_RX_RING = 6;

const int NETLINK_TX_RING = 7;

const int NETLINK_LISTEN_ALL_NSID = 8;

const int NETLINK_LIST_MEMBERSHIPS = 9;

const int NETLINK_CAP_ACK = 10;

const int NETLINK_EXT_ACK = 11;

const int NETLINK_GET_STRICT_CHK = 12;

const int IFLA_COST1 = 8;

const int IFLA_PRIORITY1 = 9;

const int IFLA_MASTER1 = 10;

const int IFLA_WIRELESS1 = 11;

const int IFLA_PROTINFO1 = 12;

const int IFLA_TXQLEN1 = 13;

const int IFLA_MAP1 = 14;

const int IFLA_WEIGHT1 = 15;

const int IFLA_LINKINFO1 = 18;

const int IFLA_PROMISCUITY1 = 30;

const int IFLA_MAX = 64;

const int IFLA_INET_MAX = 1;

const int IFLA_INET6_MAX = 9;

const int IFLA_BR_MAX = 47;

const int IFLA_BRPORT_MAX = 42;

const int IFLA_INFO_MAX = 5;

const int IFLA_VLAN_MAX = 5;

const int IFLA_VLAN_QOS_MAX = 1;

const int IFLA_MACVLAN_MAX = 8;

const int IFLA_VRF_MAX = 1;

const int IFLA_VRF_PORT_MAX = 1;

const int IFLA_MACSEC_MAX = 15;

const int IFLA_XFRM_MAX = 3;

const int IFLA_IPVLAN_MAX = 2;

const int IFLA_VXLAN_MAX = 30;

const int IFLA_GENEVE_MAX = 14;

const int IFLA_BAREUDP_MAX = 4;

const int IFLA_PPP_MAX = 1;

const int IFLA_GTP_MAX = 6;

const int IFLA_BOND_MAX = 31;

const int IFLA_BOND_AD_INFO_MAX = 5;

const int IFLA_BOND_SLAVE_MAX = 9;

const int IFLA_VF_INFO_MAX = 1;

const int IFLA_VF_MAX = 13;

const int IFLA_VF_VLAN_INFO_MAX = 1;

const int IFLA_VF_STATS_MAX = 8;

const int IFLA_VF_PORT_MAX = 1;

const int IFLA_PORT_MAX = 7;

const int IFLA_IPOIB_MAX = 3;

const int IFLA_HSR_MAX = 7;

const int IFLA_STATS_MAX = 5;

const int IFLA_STATS_GETSET_MAX = 2;

const int IFLA_OFFLOAD_XSTATS_MAX = 3;

const int IFLA_OFFLOAD_XSTATS_HW_S_INFO_MAX = 2;

const int IFLA_XDP_MAX = 8;

const int IFLA_TUN_MAX = 9;

const int IFLA_RMNET_MAX = 2;

const int IFLA_MCTP_MAX = 1;

const int IFLA_DSA_MAX = 1;

const int IFF_LOWER_UP = 65536;

const int IFF_DORMANT = 131072;

const int IFF_ECHO = 262144;

const int IFF_VOLATILE = 461914;

const int ARPHRD_NETROM = 0;

const int ARPHRD_ETHER = 1;

const int ARPHRD_EETHER = 2;

const int ARPHRD_AX25 = 3;

const int ARPHRD_PRONET = 4;

const int ARPHRD_CHAOS = 5;

const int ARPHRD_IEEE802 = 6;

const int ARPHRD_ARCNET = 7;

const int ARPHRD_APPLETLK = 8;

const int ARPHRD_DLCI = 15;

const int ARPHRD_ATM = 19;

const int ARPHRD_METRICOM = 23;

const int ARPHRD_IEEE1394 = 24;

const int ARPHRD_EUI64 = 27;

const int ARPHRD_INFINIBAND = 32;

const int ARPHRD_SLIP = 256;

const int ARPHRD_CSLIP = 257;

const int ARPHRD_SLIP6 = 258;

const int ARPHRD_CSLIP6 = 259;

const int ARPHRD_RSRVD = 260;

const int ARPHRD_ADAPT = 264;

const int ARPHRD_ROSE = 270;

const int ARPHRD_X25 = 271;

const int ARPHRD_HWX25 = 272;

const int ARPHRD_CAN = 280;

const int ARPHRD_MCTP = 290;

const int ARPHRD_PPP = 512;

const int ARPHRD_CISCO = 513;

const int ARPHRD_HDLC = 513;

const int ARPHRD_LAPB = 516;

const int ARPHRD_DDCMP = 517;

const int ARPHRD_RAWHDLC = 518;

const int ARPHRD_RAWIP = 519;

const int ARPHRD_TUNNEL = 768;

const int ARPHRD_TUNNEL6 = 769;

const int ARPHRD_FRAD = 770;

const int ARPHRD_SKIP = 771;

const int ARPHRD_LOOPBACK = 772;

const int ARPHRD_LOCALTLK = 773;

const int ARPHRD_FDDI = 774;

const int ARPHRD_BIF = 775;

const int ARPHRD_SIT = 776;

const int ARPHRD_IPDDP = 777;

const int ARPHRD_IPGRE = 778;

const int ARPHRD_PIMREG = 779;

const int ARPHRD_HIPPI = 780;

const int ARPHRD_ASH = 781;

const int ARPHRD_ECONET = 782;

const int ARPHRD_IRDA = 783;

const int ARPHRD_FCPP = 784;

const int ARPHRD_FCAL = 785;

const int ARPHRD_FCPL = 786;

const int ARPHRD_FCFABRIC = 787;

const int ARPHRD_IEEE802_TR = 800;

const int ARPHRD_IEEE80211 = 801;

const int ARPHRD_IEEE80211_PRISM = 802;

const int ARPHRD_IEEE80211_RADIOTAP = 803;

const int ARPHRD_IEEE802154 = 804;

const int ARPHRD_IEEE802154_MONITOR = 805;

const int ARPHRD_PHONET = 820;

const int ARPHRD_PHONET_PIPE = 821;

const int ARPHRD_CAIF = 822;

const int ARPHRD_IP6GRE = 823;

const int ARPHRD_NETLINK = 824;

const int ARPHRD_6LOWPAN = 825;

const int ARPHRD_VSOCKMON = 826;

const int ARPHRD_VOID = 65535;

const int ARPHRD_NONE = 65534;

const int RTM_BASE = 16;

const int RTM_NEWLINK = 16;

const int RTM_DELLINK = 17;

const int RTM_GETLINK = 18;

const int RTM_SETLINK = 19;

const int RTM_NEWADDR = 20;

const int RTM_DELADDR = 21;

const int RTM_GETADDR = 22;

const int RTM_NEWROUTE = 24;

const int RTM_DELROUTE = 25;

const int RTM_GETROUTE = 26;

const int RTM_NEWNEIGH = 28;

const int RTM_DELNEIGH = 29;

const int RTM_GETNEIGH = 30;

const int RTM_NEWRULE = 32;

const int RTM_DELRULE = 33;

const int RTM_GETRULE = 34;

const int RTM_NEWQDISC = 36;

const int RTM_DELQDISC = 37;

const int RTM_GETQDISC = 38;

const int RTM_NEWTCLASS = 40;

const int RTM_DELTCLASS = 41;

const int RTM_GETTCLASS = 42;

const int RTM_NEWTFILTER = 44;

const int RTM_DELTFILTER = 45;

const int RTM_GETTFILTER = 46;

const int RTM_NEWACTION = 48;

const int RTM_DELACTION = 49;

const int RTM_GETACTION = 50;

const int RTM_NEWPREFIX = 52;

const int RTM_GETMULTICAST = 58;

const int RTM_GETANYCAST = 62;

const int RTM_NEWNEIGHTBL = 64;

const int RTM_GETNEIGHTBL = 66;

const int RTM_SETNEIGHTBL = 67;

const int RTM_NEWNDUSEROPT = 68;

const int RTM_NEWADDRLABEL = 72;

const int RTM_DELADDRLABEL = 73;

const int RTM_GETADDRLABEL = 74;

const int RTM_GETDCB = 78;

const int RTM_SETDCB = 79;

const int RTM_NEWNETCONF = 80;

const int RTM_DELNETCONF = 81;

const int RTM_GETNETCONF = 82;

const int RTM_NEWMDB = 84;

const int RTM_DELMDB = 85;

const int RTM_GETMDB = 86;

const int RTM_NEWNSID = 88;

const int RTM_DELNSID = 89;

const int RTM_GETNSID = 90;

const int RTM_NEWSTATS = 92;

const int RTM_GETSTATS = 94;

const int RTM_SETSTATS = 95;

const int RTM_NEWCACHEREPORT = 96;

const int RTM_NEWCHAIN = 100;

const int RTM_DELCHAIN = 101;

const int RTM_GETCHAIN = 102;

const int RTM_NEWNEXTHOP = 104;

const int RTM_DELNEXTHOP = 105;

const int RTM_GETNEXTHOP = 106;

const int RTM_NEWLINKPROP = 108;

const int RTM_DELLINKPROP = 109;

const int RTM_GETLINKPROP = 110;

const int RTM_NEWNVLAN = 112;

const int RTM_DELVLAN = 113;

const int RTM_GETVLAN = 114;

const int RTM_NEWNEXTHOPBUCKET = 116;

const int RTM_DELNEXTHOPBUCKET = 117;

const int RTM_GETNEXTHOPBUCKET = 118;

const int RTM_NEWTUNNEL = 120;

const int RTM_DELTUNNEL = 121;

const int RTM_GETTUNNEL = 122;

const int RTM_MAX = 123;

const int RTM_NR_MSGTYPES = 108;

const int RTM_NR_FAMILIES = 27;

const int RTA_ALIGNTO = 4;

const int RTM_F_NOTIFY = 256;

const int RTM_F_CLONED = 512;

const int RTM_F_EQUALIZE = 1024;

const int RTM_F_PREFIX = 2048;

const int RTM_F_LOOKUP_TABLE = 4096;

const int RTM_F_FIB_MATCH = 8192;

const int RTM_F_OFFLOAD = 16384;

const int RTM_F_TRAP = 32768;

const int RTM_F_OFFLOAD_FAILED = 536870912;

const int RTA_MAX = 30;

const int CAN_CTRLMODE_LOOPBACK = 1;

const int CAN_CTRLMODE_LISTENONLY = 2;

const int CAN_CTRLMODE_3_SAMPLES = 4;

const int CAN_CTRLMODE_ONE_SHOT = 8;

const int CAN_CTRLMODE_BERR_REPORTING = 16;

const int CAN_CTRLMODE_FD = 32;

const int CAN_CTRLMODE_PRESUME_ACK = 64;

const int CAN_CTRLMODE_FD_NON_ISO = 128;

const int CAN_CTRLMODE_CC_LEN8_DLC = 256;

const int CAN_CTRLMODE_TDC_AUTO = 512;

const int CAN_CTRLMODE_TDC_MANUAL = 1024;

const int CAN_TERMINATION_DISABLED = 0;
